// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Packet_004_Office.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Packet_5f004_5fOffice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Packet_5f004_5fOffice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Packet_5f004_5fOffice_2eproto;
namespace Protocol {
class C_OFFICE_ACCEPT_WAIT;
struct C_OFFICE_ACCEPT_WAITDefaultTypeInternal;
extern C_OFFICE_ACCEPT_WAITDefaultTypeInternal _C_OFFICE_ACCEPT_WAIT_default_instance_;
class C_OFFICE_BREAK;
struct C_OFFICE_BREAKDefaultTypeInternal;
extern C_OFFICE_BREAKDefaultTypeInternal _C_OFFICE_BREAK_default_instance_;
class C_OFFICE_GET_HOST;
struct C_OFFICE_GET_HOSTDefaultTypeInternal;
extern C_OFFICE_GET_HOSTDefaultTypeInternal _C_OFFICE_GET_HOST_default_instance_;
class C_OFFICE_GET_PERMISSION;
struct C_OFFICE_GET_PERMISSIONDefaultTypeInternal;
extern C_OFFICE_GET_PERMISSIONDefaultTypeInternal _C_OFFICE_GET_PERMISSION_default_instance_;
class C_OFFICE_GET_ROOM_INFO;
struct C_OFFICE_GET_ROOM_INFODefaultTypeInternal;
extern C_OFFICE_GET_ROOM_INFODefaultTypeInternal _C_OFFICE_GET_ROOM_INFO_default_instance_;
class C_OFFICE_GET_WAITING_LIST;
struct C_OFFICE_GET_WAITING_LISTDefaultTypeInternal;
extern C_OFFICE_GET_WAITING_LISTDefaultTypeInternal _C_OFFICE_GET_WAITING_LIST_default_instance_;
class C_OFFICE_KICK;
struct C_OFFICE_KICKDefaultTypeInternal;
extern C_OFFICE_KICKDefaultTypeInternal _C_OFFICE_KICK_default_instance_;
class C_OFFICE_SET_PERMISSION;
struct C_OFFICE_SET_PERMISSIONDefaultTypeInternal;
extern C_OFFICE_SET_PERMISSIONDefaultTypeInternal _C_OFFICE_SET_PERMISSION_default_instance_;
class C_OFFICE_SET_ROOM_INFO;
struct C_OFFICE_SET_ROOM_INFODefaultTypeInternal;
extern C_OFFICE_SET_ROOM_INFODefaultTypeInternal _C_OFFICE_SET_ROOM_INFO_default_instance_;
class C_OFFICE_VIDEO_STREAM;
struct C_OFFICE_VIDEO_STREAMDefaultTypeInternal;
extern C_OFFICE_VIDEO_STREAMDefaultTypeInternal _C_OFFICE_VIDEO_STREAM_default_instance_;
class S_OFFICE_ACCEPT_WAIT;
struct S_OFFICE_ACCEPT_WAITDefaultTypeInternal;
extern S_OFFICE_ACCEPT_WAITDefaultTypeInternal _S_OFFICE_ACCEPT_WAIT_default_instance_;
class S_OFFICE_ACCEPT_WAIT_NOTICE;
struct S_OFFICE_ACCEPT_WAIT_NOTICEDefaultTypeInternal;
extern S_OFFICE_ACCEPT_WAIT_NOTICEDefaultTypeInternal _S_OFFICE_ACCEPT_WAIT_NOTICE_default_instance_;
class S_OFFICE_ADD_WAITING_CLIENT;
struct S_OFFICE_ADD_WAITING_CLIENTDefaultTypeInternal;
extern S_OFFICE_ADD_WAITING_CLIENTDefaultTypeInternal _S_OFFICE_ADD_WAITING_CLIENT_default_instance_;
class S_OFFICE_BREAK;
struct S_OFFICE_BREAKDefaultTypeInternal;
extern S_OFFICE_BREAKDefaultTypeInternal _S_OFFICE_BREAK_default_instance_;
class S_OFFICE_GET_HOST;
struct S_OFFICE_GET_HOSTDefaultTypeInternal;
extern S_OFFICE_GET_HOSTDefaultTypeInternal _S_OFFICE_GET_HOST_default_instance_;
class S_OFFICE_GET_PERMISSION;
struct S_OFFICE_GET_PERMISSIONDefaultTypeInternal;
extern S_OFFICE_GET_PERMISSIONDefaultTypeInternal _S_OFFICE_GET_PERMISSION_default_instance_;
class S_OFFICE_GET_ROOM_INFO;
struct S_OFFICE_GET_ROOM_INFODefaultTypeInternal;
extern S_OFFICE_GET_ROOM_INFODefaultTypeInternal _S_OFFICE_GET_ROOM_INFO_default_instance_;
class S_OFFICE_KICK;
struct S_OFFICE_KICKDefaultTypeInternal;
extern S_OFFICE_KICKDefaultTypeInternal _S_OFFICE_KICK_default_instance_;
class S_OFFICE_REMOVE_WAITING_CLIENT;
struct S_OFFICE_REMOVE_WAITING_CLIENTDefaultTypeInternal;
extern S_OFFICE_REMOVE_WAITING_CLIENTDefaultTypeInternal _S_OFFICE_REMOVE_WAITING_CLIENT_default_instance_;
class S_OFFICE_SET_PERMISSION;
struct S_OFFICE_SET_PERMISSIONDefaultTypeInternal;
extern S_OFFICE_SET_PERMISSIONDefaultTypeInternal _S_OFFICE_SET_PERMISSION_default_instance_;
class S_OFFICE_SET_PERMISSION_NOTICE;
struct S_OFFICE_SET_PERMISSION_NOTICEDefaultTypeInternal;
extern S_OFFICE_SET_PERMISSION_NOTICEDefaultTypeInternal _S_OFFICE_SET_PERMISSION_NOTICE_default_instance_;
class S_OFFICE_SET_ROOM_INFO;
struct S_OFFICE_SET_ROOM_INFODefaultTypeInternal;
extern S_OFFICE_SET_ROOM_INFODefaultTypeInternal _S_OFFICE_SET_ROOM_INFO_default_instance_;
class S_OFFICE_VIDEO_STREAM;
struct S_OFFICE_VIDEO_STREAMDefaultTypeInternal;
extern S_OFFICE_VIDEO_STREAMDefaultTypeInternal _S_OFFICE_VIDEO_STREAM_default_instance_;
class USER_PERMISSION;
struct USER_PERMISSIONDefaultTypeInternal;
extern USER_PERMISSIONDefaultTypeInternal _USER_PERMISSION_default_instance_;
class WaitClient;
struct WaitClientDefaultTypeInternal;
extern WaitClientDefaultTypeInternal _WaitClient_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_OFFICE_ACCEPT_WAIT* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_ACCEPT_WAIT>(Arena*);
template<> ::Protocol::C_OFFICE_BREAK* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_BREAK>(Arena*);
template<> ::Protocol::C_OFFICE_GET_HOST* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_HOST>(Arena*);
template<> ::Protocol::C_OFFICE_GET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_PERMISSION>(Arena*);
template<> ::Protocol::C_OFFICE_GET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_ROOM_INFO>(Arena*);
template<> ::Protocol::C_OFFICE_GET_WAITING_LIST* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_WAITING_LIST>(Arena*);
template<> ::Protocol::C_OFFICE_KICK* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_KICK>(Arena*);
template<> ::Protocol::C_OFFICE_SET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_SET_PERMISSION>(Arena*);
template<> ::Protocol::C_OFFICE_SET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_SET_ROOM_INFO>(Arena*);
template<> ::Protocol::C_OFFICE_VIDEO_STREAM* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_VIDEO_STREAM>(Arena*);
template<> ::Protocol::S_OFFICE_ACCEPT_WAIT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ACCEPT_WAIT>(Arena*);
template<> ::Protocol::S_OFFICE_ACCEPT_WAIT_NOTICE* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ACCEPT_WAIT_NOTICE>(Arena*);
template<> ::Protocol::S_OFFICE_ADD_WAITING_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ADD_WAITING_CLIENT>(Arena*);
template<> ::Protocol::S_OFFICE_BREAK* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_BREAK>(Arena*);
template<> ::Protocol::S_OFFICE_GET_HOST* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_HOST>(Arena*);
template<> ::Protocol::S_OFFICE_GET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_PERMISSION>(Arena*);
template<> ::Protocol::S_OFFICE_GET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_ROOM_INFO>(Arena*);
template<> ::Protocol::S_OFFICE_KICK* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_KICK>(Arena*);
template<> ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT>(Arena*);
template<> ::Protocol::S_OFFICE_SET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SET_PERMISSION>(Arena*);
template<> ::Protocol::S_OFFICE_SET_PERMISSION_NOTICE* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SET_PERMISSION_NOTICE>(Arena*);
template<> ::Protocol::S_OFFICE_SET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SET_ROOM_INFO>(Arena*);
template<> ::Protocol::S_OFFICE_VIDEO_STREAM* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_VIDEO_STREAM>(Arena*);
template<> ::Protocol::USER_PERMISSION* Arena::CreateMaybeMessage<::Protocol::USER_PERMISSION>(Arena*);
template<> ::Protocol::WaitClient* Arena::CreateMaybeMessage<::Protocol::WaitClient>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_OFFICE_GET_WAITING_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_WAITING_LIST) */ {
 public:
  inline C_OFFICE_GET_WAITING_LIST() : C_OFFICE_GET_WAITING_LIST(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_WAITING_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_WAITING_LIST(const C_OFFICE_GET_WAITING_LIST& from);
  C_OFFICE_GET_WAITING_LIST(C_OFFICE_GET_WAITING_LIST&& from) noexcept
    : C_OFFICE_GET_WAITING_LIST() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_WAITING_LIST& operator=(const C_OFFICE_GET_WAITING_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_WAITING_LIST& operator=(C_OFFICE_GET_WAITING_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_WAITING_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_WAITING_LIST* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_WAITING_LIST*>(
               &_C_OFFICE_GET_WAITING_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_OFFICE_GET_WAITING_LIST& a, C_OFFICE_GET_WAITING_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_WAITING_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_WAITING_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_WAITING_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_WAITING_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_WAITING_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_WAITING_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_WAITING_LIST";
  }
  protected:
  explicit C_OFFICE_GET_WAITING_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_WAITING_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class WaitClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.WaitClient) */ {
 public:
  inline WaitClient() : WaitClient(nullptr) {}
  ~WaitClient() override;
  explicit PROTOBUF_CONSTEXPR WaitClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitClient(const WaitClient& from);
  WaitClient(WaitClient&& from) noexcept
    : WaitClient() {
    *this = ::std::move(from);
  }

  inline WaitClient& operator=(const WaitClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitClient& operator=(WaitClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitClient* internal_default_instance() {
    return reinterpret_cast<const WaitClient*>(
               &_WaitClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WaitClient& a, WaitClient& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WaitClient& from) {
    WaitClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.WaitClient";
  }
  protected:
  explicit WaitClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 2,
    kNicknameFieldNumber = 3,
    kIsObserverFieldNumber = 1,
  };
  // string clientId = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string nickname = 3;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // bool isObserver = 1;
  void clear_isobserver();
  bool isobserver() const;
  void set_isobserver(bool value);
  private:
  bool _internal_isobserver() const;
  void _internal_set_isobserver(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.WaitClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    bool isobserver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ADD_WAITING_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ADD_WAITING_CLIENT) */ {
 public:
  inline S_OFFICE_ADD_WAITING_CLIENT() : S_OFFICE_ADD_WAITING_CLIENT(nullptr) {}
  ~S_OFFICE_ADD_WAITING_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ADD_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ADD_WAITING_CLIENT(const S_OFFICE_ADD_WAITING_CLIENT& from);
  S_OFFICE_ADD_WAITING_CLIENT(S_OFFICE_ADD_WAITING_CLIENT&& from) noexcept
    : S_OFFICE_ADD_WAITING_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ADD_WAITING_CLIENT& operator=(const S_OFFICE_ADD_WAITING_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ADD_WAITING_CLIENT& operator=(S_OFFICE_ADD_WAITING_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ADD_WAITING_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ADD_WAITING_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ADD_WAITING_CLIENT*>(
               &_S_OFFICE_ADD_WAITING_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_OFFICE_ADD_WAITING_CLIENT& a, S_OFFICE_ADD_WAITING_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ADD_WAITING_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ADD_WAITING_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ADD_WAITING_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ADD_WAITING_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ADD_WAITING_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ADD_WAITING_CLIENT& from) {
    S_OFFICE_ADD_WAITING_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ADD_WAITING_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ADD_WAITING_CLIENT";
  }
  protected:
  explicit S_OFFICE_ADD_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 1,
  };
  // repeated .Protocol.WaitClient clients = 1;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::Protocol::WaitClient* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::WaitClient >*
      mutable_clients();
  private:
  const ::Protocol::WaitClient& _internal_clients(int index) const;
  ::Protocol::WaitClient* _internal_add_clients();
  public:
  const ::Protocol::WaitClient& clients(int index) const;
  ::Protocol::WaitClient* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::WaitClient >&
      clients() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ADD_WAITING_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::WaitClient > clients_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_REMOVE_WAITING_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT) */ {
 public:
  inline S_OFFICE_REMOVE_WAITING_CLIENT() : S_OFFICE_REMOVE_WAITING_CLIENT(nullptr) {}
  ~S_OFFICE_REMOVE_WAITING_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_REMOVE_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_REMOVE_WAITING_CLIENT(const S_OFFICE_REMOVE_WAITING_CLIENT& from);
  S_OFFICE_REMOVE_WAITING_CLIENT(S_OFFICE_REMOVE_WAITING_CLIENT&& from) noexcept
    : S_OFFICE_REMOVE_WAITING_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_REMOVE_WAITING_CLIENT& operator=(const S_OFFICE_REMOVE_WAITING_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_REMOVE_WAITING_CLIENT& operator=(S_OFFICE_REMOVE_WAITING_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_REMOVE_WAITING_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_REMOVE_WAITING_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_REMOVE_WAITING_CLIENT*>(
               &_S_OFFICE_REMOVE_WAITING_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_OFFICE_REMOVE_WAITING_CLIENT& a, S_OFFICE_REMOVE_WAITING_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_REMOVE_WAITING_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_REMOVE_WAITING_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_REMOVE_WAITING_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_REMOVE_WAITING_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_REMOVE_WAITING_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_REMOVE_WAITING_CLIENT& from) {
    S_OFFICE_REMOVE_WAITING_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_REMOVE_WAITING_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_REMOVE_WAITING_CLIENT";
  }
  protected:
  explicit S_OFFICE_REMOVE_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 1,
  };
  // repeated string clients = 1;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  const std::string& clients(int index) const;
  std::string* mutable_clients(int index);
  void set_clients(int index, const std::string& value);
  void set_clients(int index, std::string&& value);
  void set_clients(int index, const char* value);
  void set_clients(int index, const char* value, size_t size);
  std::string* add_clients();
  void add_clients(const std::string& value);
  void add_clients(std::string&& value);
  void add_clients(const char* value);
  void add_clients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clients();
  private:
  const std::string& _internal_clients(int index) const;
  std::string* _internal_add_clients();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clients_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_ACCEPT_WAIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_ACCEPT_WAIT) */ {
 public:
  inline C_OFFICE_ACCEPT_WAIT() : C_OFFICE_ACCEPT_WAIT(nullptr) {}
  ~C_OFFICE_ACCEPT_WAIT() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_ACCEPT_WAIT(const C_OFFICE_ACCEPT_WAIT& from);
  C_OFFICE_ACCEPT_WAIT(C_OFFICE_ACCEPT_WAIT&& from) noexcept
    : C_OFFICE_ACCEPT_WAIT() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_ACCEPT_WAIT& operator=(const C_OFFICE_ACCEPT_WAIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_ACCEPT_WAIT& operator=(C_OFFICE_ACCEPT_WAIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_ACCEPT_WAIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_ACCEPT_WAIT* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_ACCEPT_WAIT*>(
               &_C_OFFICE_ACCEPT_WAIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_OFFICE_ACCEPT_WAIT& a, C_OFFICE_ACCEPT_WAIT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_ACCEPT_WAIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_ACCEPT_WAIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_ACCEPT_WAIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_ACCEPT_WAIT& from) {
    C_OFFICE_ACCEPT_WAIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_ACCEPT_WAIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_ACCEPT_WAIT";
  }
  protected:
  explicit C_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kIsAcceptedFieldNumber = 2,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // bool isAccepted = 2;
  void clear_isaccepted();
  bool isaccepted() const;
  void set_isaccepted(bool value);
  private:
  bool _internal_isaccepted() const;
  void _internal_set_isaccepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_ACCEPT_WAIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    bool isaccepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ACCEPT_WAIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ACCEPT_WAIT) */ {
 public:
  inline S_OFFICE_ACCEPT_WAIT() : S_OFFICE_ACCEPT_WAIT(nullptr) {}
  ~S_OFFICE_ACCEPT_WAIT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ACCEPT_WAIT(const S_OFFICE_ACCEPT_WAIT& from);
  S_OFFICE_ACCEPT_WAIT(S_OFFICE_ACCEPT_WAIT&& from) noexcept
    : S_OFFICE_ACCEPT_WAIT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ACCEPT_WAIT& operator=(const S_OFFICE_ACCEPT_WAIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ACCEPT_WAIT& operator=(S_OFFICE_ACCEPT_WAIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ACCEPT_WAIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ACCEPT_WAIT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ACCEPT_WAIT*>(
               &_S_OFFICE_ACCEPT_WAIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_OFFICE_ACCEPT_WAIT& a, S_OFFICE_ACCEPT_WAIT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ACCEPT_WAIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ACCEPT_WAIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ACCEPT_WAIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ACCEPT_WAIT& from) {
    S_OFFICE_ACCEPT_WAIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ACCEPT_WAIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ACCEPT_WAIT";
  }
  protected:
  explicit S_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ACCEPT_WAIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ACCEPT_WAIT_NOTICE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE) */ {
 public:
  inline S_OFFICE_ACCEPT_WAIT_NOTICE() : S_OFFICE_ACCEPT_WAIT_NOTICE(nullptr) {}
  ~S_OFFICE_ACCEPT_WAIT_NOTICE() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ACCEPT_WAIT_NOTICE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ACCEPT_WAIT_NOTICE(const S_OFFICE_ACCEPT_WAIT_NOTICE& from);
  S_OFFICE_ACCEPT_WAIT_NOTICE(S_OFFICE_ACCEPT_WAIT_NOTICE&& from) noexcept
    : S_OFFICE_ACCEPT_WAIT_NOTICE() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ACCEPT_WAIT_NOTICE& operator=(const S_OFFICE_ACCEPT_WAIT_NOTICE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ACCEPT_WAIT_NOTICE& operator=(S_OFFICE_ACCEPT_WAIT_NOTICE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ACCEPT_WAIT_NOTICE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ACCEPT_WAIT_NOTICE* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ACCEPT_WAIT_NOTICE*>(
               &_S_OFFICE_ACCEPT_WAIT_NOTICE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_OFFICE_ACCEPT_WAIT_NOTICE& a, S_OFFICE_ACCEPT_WAIT_NOTICE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ACCEPT_WAIT_NOTICE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ACCEPT_WAIT_NOTICE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ACCEPT_WAIT_NOTICE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ACCEPT_WAIT_NOTICE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ACCEPT_WAIT_NOTICE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ACCEPT_WAIT_NOTICE& from) {
    S_OFFICE_ACCEPT_WAIT_NOTICE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ACCEPT_WAIT_NOTICE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE";
  }
  protected:
  explicit S_OFFICE_ACCEPT_WAIT_NOTICE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAcceptedFieldNumber = 1,
  };
  // bool isAccepted = 1;
  void clear_isaccepted();
  bool isaccepted() const;
  void set_isaccepted(bool value);
  private:
  bool _internal_isaccepted() const;
  void _internal_set_isaccepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isaccepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_HOST final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_HOST) */ {
 public:
  inline C_OFFICE_GET_HOST() : C_OFFICE_GET_HOST(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_HOST(const C_OFFICE_GET_HOST& from);
  C_OFFICE_GET_HOST(C_OFFICE_GET_HOST&& from) noexcept
    : C_OFFICE_GET_HOST() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_HOST& operator=(const C_OFFICE_GET_HOST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_HOST& operator=(C_OFFICE_GET_HOST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_HOST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_HOST* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_HOST*>(
               &_C_OFFICE_GET_HOST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_OFFICE_GET_HOST& a, C_OFFICE_GET_HOST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_HOST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_HOST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_HOST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_HOST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_HOST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_HOST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_HOST";
  }
  protected:
  explicit C_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_HOST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_HOST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_HOST) */ {
 public:
  inline S_OFFICE_GET_HOST() : S_OFFICE_GET_HOST(nullptr) {}
  ~S_OFFICE_GET_HOST() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_HOST(const S_OFFICE_GET_HOST& from);
  S_OFFICE_GET_HOST(S_OFFICE_GET_HOST&& from) noexcept
    : S_OFFICE_GET_HOST() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_HOST& operator=(const S_OFFICE_GET_HOST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_HOST& operator=(S_OFFICE_GET_HOST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_HOST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_HOST* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_HOST*>(
               &_S_OFFICE_GET_HOST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_OFFICE_GET_HOST& a, S_OFFICE_GET_HOST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_HOST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_HOST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_HOST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_HOST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_HOST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_HOST& from) {
    S_OFFICE_GET_HOST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_HOST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_HOST";
  }
  protected:
  explicit S_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_HOST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_BREAK final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_BREAK) */ {
 public:
  inline C_OFFICE_BREAK() : C_OFFICE_BREAK(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_BREAK(const C_OFFICE_BREAK& from);
  C_OFFICE_BREAK(C_OFFICE_BREAK&& from) noexcept
    : C_OFFICE_BREAK() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_BREAK& operator=(const C_OFFICE_BREAK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_BREAK& operator=(C_OFFICE_BREAK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_BREAK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_BREAK* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_BREAK*>(
               &_C_OFFICE_BREAK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_OFFICE_BREAK& a, C_OFFICE_BREAK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_BREAK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_BREAK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_BREAK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_BREAK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_BREAK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_BREAK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_BREAK";
  }
  protected:
  explicit C_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_BREAK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_BREAK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_BREAK) */ {
 public:
  inline S_OFFICE_BREAK() : S_OFFICE_BREAK(nullptr) {}
  ~S_OFFICE_BREAK() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_BREAK(const S_OFFICE_BREAK& from);
  S_OFFICE_BREAK(S_OFFICE_BREAK&& from) noexcept
    : S_OFFICE_BREAK() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_BREAK& operator=(const S_OFFICE_BREAK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_BREAK& operator=(S_OFFICE_BREAK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_BREAK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_BREAK* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_BREAK*>(
               &_S_OFFICE_BREAK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_OFFICE_BREAK& a, S_OFFICE_BREAK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_BREAK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_BREAK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_BREAK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_BREAK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_BREAK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_BREAK& from) {
    S_OFFICE_BREAK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_BREAK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_BREAK";
  }
  protected:
  explicit S_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_BREAK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_KICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_KICK) */ {
 public:
  inline C_OFFICE_KICK() : C_OFFICE_KICK(nullptr) {}
  ~C_OFFICE_KICK() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_KICK(const C_OFFICE_KICK& from);
  C_OFFICE_KICK(C_OFFICE_KICK&& from) noexcept
    : C_OFFICE_KICK() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_KICK& operator=(const C_OFFICE_KICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_KICK& operator=(C_OFFICE_KICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_KICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_KICK* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_KICK*>(
               &_C_OFFICE_KICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_OFFICE_KICK& a, C_OFFICE_KICK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_KICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_KICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_KICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_KICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_KICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_KICK& from) {
    C_OFFICE_KICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_KICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_KICK";
  }
  protected:
  explicit C_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_KICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_KICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_KICK) */ {
 public:
  inline S_OFFICE_KICK() : S_OFFICE_KICK(nullptr) {}
  ~S_OFFICE_KICK() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_KICK(const S_OFFICE_KICK& from);
  S_OFFICE_KICK(S_OFFICE_KICK&& from) noexcept
    : S_OFFICE_KICK() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_KICK& operator=(const S_OFFICE_KICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_KICK& operator=(S_OFFICE_KICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_KICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_KICK* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_KICK*>(
               &_S_OFFICE_KICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_OFFICE_KICK& a, S_OFFICE_KICK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_KICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_KICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_KICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_KICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_KICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_KICK& from) {
    S_OFFICE_KICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_KICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_KICK";
  }
  protected:
  explicit S_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_KICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class USER_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.USER_PERMISSION) */ {
 public:
  inline USER_PERMISSION() : USER_PERMISSION(nullptr) {}
  ~USER_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR USER_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  USER_PERMISSION(const USER_PERMISSION& from);
  USER_PERMISSION(USER_PERMISSION&& from) noexcept
    : USER_PERMISSION() {
    *this = ::std::move(from);
  }

  inline USER_PERMISSION& operator=(const USER_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline USER_PERMISSION& operator=(USER_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const USER_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const USER_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const USER_PERMISSION*>(
               &_USER_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(USER_PERMISSION& a, USER_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(USER_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(USER_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  USER_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<USER_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const USER_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const USER_PERMISSION& from) {
    USER_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(USER_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.USER_PERMISSION";
  }
  protected:
  explicit USER_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kScreenPermissionFieldNumber = 2,
    kChatPermissionFieldNumber = 3,
    kVoicePermissionFieldNumber = 4,
    kVideoPermissionFieldNumber = 5,
    kTypeFieldNumber = 6,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // bool screenPermission = 2;
  void clear_screenpermission();
  bool screenpermission() const;
  void set_screenpermission(bool value);
  private:
  bool _internal_screenpermission() const;
  void _internal_set_screenpermission(bool value);
  public:

  // bool chatPermission = 3;
  void clear_chatpermission();
  bool chatpermission() const;
  void set_chatpermission(bool value);
  private:
  bool _internal_chatpermission() const;
  void _internal_set_chatpermission(bool value);
  public:

  // bool voicePermission = 4;
  void clear_voicepermission();
  bool voicepermission() const;
  void set_voicepermission(bool value);
  private:
  bool _internal_voicepermission() const;
  void _internal_set_voicepermission(bool value);
  public:

  // bool videoPermission = 5;
  void clear_videopermission();
  bool videopermission() const;
  void set_videopermission(bool value);
  private:
  bool _internal_videopermission() const;
  void _internal_set_videopermission(bool value);
  public:

  // int32 type = 6;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.USER_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    bool screenpermission_;
    bool chatpermission_;
    bool voicepermission_;
    bool videopermission_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_PERMISSION) */ {
 public:
  inline C_OFFICE_GET_PERMISSION() : C_OFFICE_GET_PERMISSION(nullptr) {}
  ~C_OFFICE_GET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_PERMISSION(const C_OFFICE_GET_PERMISSION& from);
  C_OFFICE_GET_PERMISSION(C_OFFICE_GET_PERMISSION&& from) noexcept
    : C_OFFICE_GET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_PERMISSION& operator=(const C_OFFICE_GET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_PERMISSION& operator=(C_OFFICE_GET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_PERMISSION*>(
               &_C_OFFICE_GET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(C_OFFICE_GET_PERMISSION& a, C_OFFICE_GET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_GET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_GET_PERMISSION& from) {
    C_OFFICE_GET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_GET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_PERMISSION";
  }
  protected:
  explicit C_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_PERMISSION) */ {
 public:
  inline S_OFFICE_GET_PERMISSION() : S_OFFICE_GET_PERMISSION(nullptr) {}
  ~S_OFFICE_GET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_PERMISSION(const S_OFFICE_GET_PERMISSION& from);
  S_OFFICE_GET_PERMISSION(S_OFFICE_GET_PERMISSION&& from) noexcept
    : S_OFFICE_GET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_PERMISSION& operator=(const S_OFFICE_GET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_PERMISSION& operator=(S_OFFICE_GET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_PERMISSION*>(
               &_S_OFFICE_GET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_OFFICE_GET_PERMISSION& a, S_OFFICE_GET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_PERMISSION& from) {
    S_OFFICE_GET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_PERMISSION";
  }
  protected:
  explicit S_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .Protocol.USER_PERMISSION permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::Protocol::USER_PERMISSION* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >*
      mutable_permissions();
  private:
  const ::Protocol::USER_PERMISSION& _internal_permissions(int index) const;
  ::Protocol::USER_PERMISSION* _internal_add_permissions();
  public:
  const ::Protocol::USER_PERMISSION& permissions(int index) const;
  ::Protocol::USER_PERMISSION* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION > permissions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_SET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_SET_PERMISSION) */ {
 public:
  inline C_OFFICE_SET_PERMISSION() : C_OFFICE_SET_PERMISSION(nullptr) {}
  ~C_OFFICE_SET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_SET_PERMISSION(const C_OFFICE_SET_PERMISSION& from);
  C_OFFICE_SET_PERMISSION(C_OFFICE_SET_PERMISSION&& from) noexcept
    : C_OFFICE_SET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_SET_PERMISSION& operator=(const C_OFFICE_SET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_SET_PERMISSION& operator=(C_OFFICE_SET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_SET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_SET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_SET_PERMISSION*>(
               &_C_OFFICE_SET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_OFFICE_SET_PERMISSION& a, C_OFFICE_SET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_SET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_SET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_SET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_SET_PERMISSION& from) {
    C_OFFICE_SET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_SET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_SET_PERMISSION";
  }
  protected:
  explicit C_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .Protocol.USER_PERMISSION permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::Protocol::USER_PERMISSION* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >*
      mutable_permissions();
  private:
  const ::Protocol::USER_PERMISSION& _internal_permissions(int index) const;
  ::Protocol::USER_PERMISSION* _internal_add_permissions();
  public:
  const ::Protocol::USER_PERMISSION& permissions(int index) const;
  ::Protocol::USER_PERMISSION* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_SET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION > permissions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SET_PERMISSION) */ {
 public:
  inline S_OFFICE_SET_PERMISSION() : S_OFFICE_SET_PERMISSION(nullptr) {}
  ~S_OFFICE_SET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SET_PERMISSION(const S_OFFICE_SET_PERMISSION& from);
  S_OFFICE_SET_PERMISSION(S_OFFICE_SET_PERMISSION&& from) noexcept
    : S_OFFICE_SET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SET_PERMISSION& operator=(const S_OFFICE_SET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SET_PERMISSION& operator=(S_OFFICE_SET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SET_PERMISSION*>(
               &_S_OFFICE_SET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_OFFICE_SET_PERMISSION& a, S_OFFICE_SET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SET_PERMISSION& from) {
    S_OFFICE_SET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SET_PERMISSION";
  }
  protected:
  explicit S_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SET_PERMISSION_NOTICE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SET_PERMISSION_NOTICE) */ {
 public:
  inline S_OFFICE_SET_PERMISSION_NOTICE() : S_OFFICE_SET_PERMISSION_NOTICE(nullptr) {}
  ~S_OFFICE_SET_PERMISSION_NOTICE() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SET_PERMISSION_NOTICE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SET_PERMISSION_NOTICE(const S_OFFICE_SET_PERMISSION_NOTICE& from);
  S_OFFICE_SET_PERMISSION_NOTICE(S_OFFICE_SET_PERMISSION_NOTICE&& from) noexcept
    : S_OFFICE_SET_PERMISSION_NOTICE() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SET_PERMISSION_NOTICE& operator=(const S_OFFICE_SET_PERMISSION_NOTICE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SET_PERMISSION_NOTICE& operator=(S_OFFICE_SET_PERMISSION_NOTICE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SET_PERMISSION_NOTICE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SET_PERMISSION_NOTICE* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SET_PERMISSION_NOTICE*>(
               &_S_OFFICE_SET_PERMISSION_NOTICE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_OFFICE_SET_PERMISSION_NOTICE& a, S_OFFICE_SET_PERMISSION_NOTICE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SET_PERMISSION_NOTICE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SET_PERMISSION_NOTICE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SET_PERMISSION_NOTICE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SET_PERMISSION_NOTICE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SET_PERMISSION_NOTICE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SET_PERMISSION_NOTICE& from) {
    S_OFFICE_SET_PERMISSION_NOTICE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SET_PERMISSION_NOTICE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SET_PERMISSION_NOTICE";
  }
  protected:
  explicit S_OFFICE_SET_PERMISSION_NOTICE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenPermissionFieldNumber = 1,
    kChatPermissionFieldNumber = 2,
    kVoicePermissionFieldNumber = 3,
    kVideoPermissionFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // bool screenPermission = 1;
  void clear_screenpermission();
  bool screenpermission() const;
  void set_screenpermission(bool value);
  private:
  bool _internal_screenpermission() const;
  void _internal_set_screenpermission(bool value);
  public:

  // bool chatPermission = 2;
  void clear_chatpermission();
  bool chatpermission() const;
  void set_chatpermission(bool value);
  private:
  bool _internal_chatpermission() const;
  void _internal_set_chatpermission(bool value);
  public:

  // bool voicePermission = 3;
  void clear_voicepermission();
  bool voicepermission() const;
  void set_voicepermission(bool value);
  private:
  bool _internal_voicepermission() const;
  void _internal_set_voicepermission(bool value);
  public:

  // bool videoPermission = 4;
  void clear_videopermission();
  bool videopermission() const;
  void set_videopermission(bool value);
  private:
  bool _internal_videopermission() const;
  void _internal_set_videopermission(bool value);
  public:

  // int32 type = 5;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SET_PERMISSION_NOTICE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool screenpermission_;
    bool chatpermission_;
    bool voicepermission_;
    bool videopermission_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_SET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_SET_ROOM_INFO) */ {
 public:
  inline C_OFFICE_SET_ROOM_INFO() : C_OFFICE_SET_ROOM_INFO(nullptr) {}
  ~C_OFFICE_SET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_SET_ROOM_INFO(const C_OFFICE_SET_ROOM_INFO& from);
  C_OFFICE_SET_ROOM_INFO(C_OFFICE_SET_ROOM_INFO&& from) noexcept
    : C_OFFICE_SET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_SET_ROOM_INFO& operator=(const C_OFFICE_SET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_SET_ROOM_INFO& operator=(C_OFFICE_SET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_SET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_SET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_SET_ROOM_INFO*>(
               &_C_OFFICE_SET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_OFFICE_SET_ROOM_INFO& a, C_OFFICE_SET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_SET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_SET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_SET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_SET_ROOM_INFO& from) {
    C_OFFICE_SET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_SET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_SET_ROOM_INFO";
  }
  protected:
  explicit C_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kPersonnelFieldNumber = 1,
    kIsShutdownFieldNumber = 3,
    kIsAdvertisingFieldNumber = 4,
    kIsWaitingRoomFieldNumber = 5,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 personnel = 1;
  void clear_personnel();
  int32_t personnel() const;
  void set_personnel(int32_t value);
  private:
  int32_t _internal_personnel() const;
  void _internal_set_personnel(int32_t value);
  public:

  // bool isShutdown = 3;
  void clear_isshutdown();
  bool isshutdown() const;
  void set_isshutdown(bool value);
  private:
  bool _internal_isshutdown() const;
  void _internal_set_isshutdown(bool value);
  public:

  // bool isAdvertising = 4;
  void clear_isadvertising();
  bool isadvertising() const;
  void set_isadvertising(bool value);
  private:
  bool _internal_isadvertising() const;
  void _internal_set_isadvertising(bool value);
  public:

  // bool isWaitingRoom = 5;
  void clear_iswaitingroom();
  bool iswaitingroom() const;
  void set_iswaitingroom(bool value);
  private:
  bool _internal_iswaitingroom() const;
  void _internal_set_iswaitingroom(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_SET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t personnel_;
    bool isshutdown_;
    bool isadvertising_;
    bool iswaitingroom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SET_ROOM_INFO) */ {
 public:
  inline S_OFFICE_SET_ROOM_INFO() : S_OFFICE_SET_ROOM_INFO(nullptr) {}
  ~S_OFFICE_SET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SET_ROOM_INFO(const S_OFFICE_SET_ROOM_INFO& from);
  S_OFFICE_SET_ROOM_INFO(S_OFFICE_SET_ROOM_INFO&& from) noexcept
    : S_OFFICE_SET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SET_ROOM_INFO& operator=(const S_OFFICE_SET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SET_ROOM_INFO& operator=(S_OFFICE_SET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SET_ROOM_INFO*>(
               &_S_OFFICE_SET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_OFFICE_SET_ROOM_INFO& a, S_OFFICE_SET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SET_ROOM_INFO& from) {
    S_OFFICE_SET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SET_ROOM_INFO";
  }
  protected:
  explicit S_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_ROOM_INFO) */ {
 public:
  inline C_OFFICE_GET_ROOM_INFO() : C_OFFICE_GET_ROOM_INFO(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_ROOM_INFO(const C_OFFICE_GET_ROOM_INFO& from);
  C_OFFICE_GET_ROOM_INFO(C_OFFICE_GET_ROOM_INFO&& from) noexcept
    : C_OFFICE_GET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_ROOM_INFO& operator=(const C_OFFICE_GET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_ROOM_INFO& operator=(C_OFFICE_GET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_ROOM_INFO*>(
               &_C_OFFICE_GET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_OFFICE_GET_ROOM_INFO& a, C_OFFICE_GET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_ROOM_INFO& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_ROOM_INFO& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_ROOM_INFO";
  }
  protected:
  explicit C_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_ROOM_INFO) */ {
 public:
  inline S_OFFICE_GET_ROOM_INFO() : S_OFFICE_GET_ROOM_INFO(nullptr) {}
  ~S_OFFICE_GET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_ROOM_INFO(const S_OFFICE_GET_ROOM_INFO& from);
  S_OFFICE_GET_ROOM_INFO(S_OFFICE_GET_ROOM_INFO&& from) noexcept
    : S_OFFICE_GET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_ROOM_INFO& operator=(const S_OFFICE_GET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_ROOM_INFO& operator=(S_OFFICE_GET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_ROOM_INFO*>(
               &_S_OFFICE_GET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_OFFICE_GET_ROOM_INFO& a, S_OFFICE_GET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_ROOM_INFO& from) {
    S_OFFICE_GET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_ROOM_INFO";
  }
  protected:
  explicit S_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kPasswordFieldNumber = 4,
    kSpaceInfoIdFieldNumber = 5,
    kThumbnailFieldNumber = 9,
    kRoomcodeFieldNumber = 14,
    kHostNicknameFieldNumber = 15,
    kTopicTypeFieldNumber = 3,
    kPersonnelFieldNumber = 6,
    kCurrentPersonnelFieldNumber = 7,
    kIsAdvertisingFieldNumber = 8,
    kIsWaitingRoomFieldNumber = 10,
    kIsShutdownFieldNumber = 11,
    kRunningTimeFieldNumber = 12,
    kPassedTimeFieldNumber = 13,
  };
  // string roomName = 1;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string spaceInfoId = 5;
  void clear_spaceinfoid();
  const std::string& spaceinfoid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceinfoid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceinfoid();
  PROTOBUF_NODISCARD std::string* release_spaceinfoid();
  void set_allocated_spaceinfoid(std::string* spaceinfoid);
  private:
  const std::string& _internal_spaceinfoid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceinfoid(const std::string& value);
  std::string* _internal_mutable_spaceinfoid();
  public:

  // string thumbnail = 9;
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // string roomcode = 14;
  void clear_roomcode();
  const std::string& roomcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomcode();
  PROTOBUF_NODISCARD std::string* release_roomcode();
  void set_allocated_roomcode(std::string* roomcode);
  private:
  const std::string& _internal_roomcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomcode(const std::string& value);
  std::string* _internal_mutable_roomcode();
  public:

  // string hostNickname = 15;
  void clear_hostnickname();
  const std::string& hostnickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostnickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostnickname();
  PROTOBUF_NODISCARD std::string* release_hostnickname();
  void set_allocated_hostnickname(std::string* hostnickname);
  private:
  const std::string& _internal_hostnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostnickname(const std::string& value);
  std::string* _internal_mutable_hostnickname();
  public:

  // int32 topicType = 3;
  void clear_topictype();
  int32_t topictype() const;
  void set_topictype(int32_t value);
  private:
  int32_t _internal_topictype() const;
  void _internal_set_topictype(int32_t value);
  public:

  // int32 personnel = 6;
  void clear_personnel();
  int32_t personnel() const;
  void set_personnel(int32_t value);
  private:
  int32_t _internal_personnel() const;
  void _internal_set_personnel(int32_t value);
  public:

  // int32 currentPersonnel = 7;
  void clear_currentpersonnel();
  int32_t currentpersonnel() const;
  void set_currentpersonnel(int32_t value);
  private:
  int32_t _internal_currentpersonnel() const;
  void _internal_set_currentpersonnel(int32_t value);
  public:

  // bool isAdvertising = 8;
  void clear_isadvertising();
  bool isadvertising() const;
  void set_isadvertising(bool value);
  private:
  bool _internal_isadvertising() const;
  void _internal_set_isadvertising(bool value);
  public:

  // bool isWaitingRoom = 10;
  void clear_iswaitingroom();
  bool iswaitingroom() const;
  void set_iswaitingroom(bool value);
  private:
  bool _internal_iswaitingroom() const;
  void _internal_set_iswaitingroom(bool value);
  public:

  // bool isShutdown = 11;
  void clear_isshutdown();
  bool isshutdown() const;
  void set_isshutdown(bool value);
  private:
  bool _internal_isshutdown() const;
  void _internal_set_isshutdown(bool value);
  public:

  // int32 runningTime = 12;
  void clear_runningtime();
  int32_t runningtime() const;
  void set_runningtime(int32_t value);
  private:
  int32_t _internal_runningtime() const;
  void _internal_set_runningtime(int32_t value);
  public:

  // int32 passedTime = 13;
  void clear_passedtime();
  int32_t passedtime() const;
  void set_passedtime(int32_t value);
  private:
  int32_t _internal_passedtime() const;
  void _internal_set_passedtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceinfoid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostnickname_;
    int32_t topictype_;
    int32_t personnel_;
    int32_t currentpersonnel_;
    bool isadvertising_;
    bool iswaitingroom_;
    bool isshutdown_;
    int32_t runningtime_;
    int32_t passedtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_VIDEO_STREAM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_VIDEO_STREAM) */ {
 public:
  inline C_OFFICE_VIDEO_STREAM() : C_OFFICE_VIDEO_STREAM(nullptr) {}
  ~C_OFFICE_VIDEO_STREAM() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_VIDEO_STREAM(const C_OFFICE_VIDEO_STREAM& from);
  C_OFFICE_VIDEO_STREAM(C_OFFICE_VIDEO_STREAM&& from) noexcept
    : C_OFFICE_VIDEO_STREAM() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_VIDEO_STREAM& operator=(const C_OFFICE_VIDEO_STREAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_VIDEO_STREAM& operator=(C_OFFICE_VIDEO_STREAM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_VIDEO_STREAM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_VIDEO_STREAM* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_VIDEO_STREAM*>(
               &_C_OFFICE_VIDEO_STREAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_OFFICE_VIDEO_STREAM& a, C_OFFICE_VIDEO_STREAM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_VIDEO_STREAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_VIDEO_STREAM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_VIDEO_STREAM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_VIDEO_STREAM& from) {
    C_OFFICE_VIDEO_STREAM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_VIDEO_STREAM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_VIDEO_STREAM";
  }
  protected:
  explicit C_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientidFieldNumber = 1,
    kUrlFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kPlayFieldNumber = 5,
    kSeekFieldNumber = 6,
    kMediaPlayerStateFieldNumber = 7,
  };
  // string clientid = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // float volume = 3;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float time = 4;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // bool play = 5;
  void clear_play();
  bool play() const;
  void set_play(bool value);
  private:
  bool _internal_play() const;
  void _internal_set_play(bool value);
  public:

  // bool seek = 6;
  void clear_seek();
  bool seek() const;
  void set_seek(bool value);
  private:
  bool _internal_seek() const;
  void _internal_set_seek(bool value);
  public:

  // int32 mediaPlayerState = 7;
  void clear_mediaplayerstate();
  int32_t mediaplayerstate() const;
  void set_mediaplayerstate(int32_t value);
  private:
  int32_t _internal_mediaplayerstate() const;
  void _internal_set_mediaplayerstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_VIDEO_STREAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    float volume_;
    float time_;
    bool play_;
    bool seek_;
    int32_t mediaplayerstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_VIDEO_STREAM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_VIDEO_STREAM) */ {
 public:
  inline S_OFFICE_VIDEO_STREAM() : S_OFFICE_VIDEO_STREAM(nullptr) {}
  ~S_OFFICE_VIDEO_STREAM() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_VIDEO_STREAM(const S_OFFICE_VIDEO_STREAM& from);
  S_OFFICE_VIDEO_STREAM(S_OFFICE_VIDEO_STREAM&& from) noexcept
    : S_OFFICE_VIDEO_STREAM() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_VIDEO_STREAM& operator=(const S_OFFICE_VIDEO_STREAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_VIDEO_STREAM& operator=(S_OFFICE_VIDEO_STREAM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_VIDEO_STREAM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_VIDEO_STREAM* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_VIDEO_STREAM*>(
               &_S_OFFICE_VIDEO_STREAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_OFFICE_VIDEO_STREAM& a, S_OFFICE_VIDEO_STREAM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_VIDEO_STREAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_VIDEO_STREAM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_VIDEO_STREAM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_VIDEO_STREAM& from) {
    S_OFFICE_VIDEO_STREAM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_VIDEO_STREAM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_VIDEO_STREAM";
  }
  protected:
  explicit S_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kVolumeFieldNumber = 2,
    kTimeFieldNumber = 3,
    kPlayFieldNumber = 4,
    kSeekFieldNumber = 5,
    kMediaPlayerStateFieldNumber = 6,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // float volume = 2;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float time = 3;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // bool play = 4;
  void clear_play();
  bool play() const;
  void set_play(bool value);
  private:
  bool _internal_play() const;
  void _internal_set_play(bool value);
  public:

  // bool seek = 5;
  void clear_seek();
  bool seek() const;
  void set_seek(bool value);
  private:
  bool _internal_seek() const;
  void _internal_set_seek(bool value);
  public:

  // int32 mediaPlayerState = 6;
  void clear_mediaplayerstate();
  int32_t mediaplayerstate() const;
  void set_mediaplayerstate(int32_t value);
  private:
  int32_t _internal_mediaplayerstate() const;
  void _internal_set_mediaplayerstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_VIDEO_STREAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    float volume_;
    float time_;
    bool play_;
    bool seek_;
    int32_t mediaplayerstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_OFFICE_GET_WAITING_LIST

// -------------------------------------------------------------------

// WaitClient

// bool isObserver = 1;
inline void WaitClient::clear_isobserver() {
  _impl_.isobserver_ = false;
}
inline bool WaitClient::_internal_isobserver() const {
  return _impl_.isobserver_;
}
inline bool WaitClient::isobserver() const {
  // @@protoc_insertion_point(field_get:Protocol.WaitClient.isObserver)
  return _internal_isobserver();
}
inline void WaitClient::_internal_set_isobserver(bool value) {
  
  _impl_.isobserver_ = value;
}
inline void WaitClient::set_isobserver(bool value) {
  _internal_set_isobserver(value);
  // @@protoc_insertion_point(field_set:Protocol.WaitClient.isObserver)
}

// string clientId = 2;
inline void WaitClient::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& WaitClient::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.WaitClient.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitClient::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.WaitClient.clientId)
}
inline std::string* WaitClient::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.WaitClient.clientId)
  return _s;
}
inline const std::string& WaitClient::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void WaitClient::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* WaitClient::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* WaitClient::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.WaitClient.clientId)
  return _impl_.clientid_.Release();
}
inline void WaitClient::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.WaitClient.clientId)
}

// string nickname = 3;
inline void WaitClient::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& WaitClient::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.WaitClient.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitClient::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.WaitClient.nickname)
}
inline std::string* WaitClient::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.WaitClient.nickname)
  return _s;
}
inline const std::string& WaitClient::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void WaitClient::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* WaitClient::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* WaitClient::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.WaitClient.nickname)
  return _impl_.nickname_.Release();
}
inline void WaitClient::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.WaitClient.nickname)
}

// -------------------------------------------------------------------

// S_OFFICE_ADD_WAITING_CLIENT

// repeated .Protocol.WaitClient clients = 1;
inline int S_OFFICE_ADD_WAITING_CLIENT::_internal_clients_size() const {
  return _impl_.clients_.size();
}
inline int S_OFFICE_ADD_WAITING_CLIENT::clients_size() const {
  return _internal_clients_size();
}
inline void S_OFFICE_ADD_WAITING_CLIENT::clear_clients() {
  _impl_.clients_.Clear();
}
inline ::Protocol::WaitClient* S_OFFICE_ADD_WAITING_CLIENT::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _impl_.clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::WaitClient >*
S_OFFICE_ADD_WAITING_CLIENT::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return &_impl_.clients_;
}
inline const ::Protocol::WaitClient& S_OFFICE_ADD_WAITING_CLIENT::_internal_clients(int index) const {
  return _impl_.clients_.Get(index);
}
inline const ::Protocol::WaitClient& S_OFFICE_ADD_WAITING_CLIENT::clients(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _internal_clients(index);
}
inline ::Protocol::WaitClient* S_OFFICE_ADD_WAITING_CLIENT::_internal_add_clients() {
  return _impl_.clients_.Add();
}
inline ::Protocol::WaitClient* S_OFFICE_ADD_WAITING_CLIENT::add_clients() {
  ::Protocol::WaitClient* _add = _internal_add_clients();
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::WaitClient >&
S_OFFICE_ADD_WAITING_CLIENT::clients() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _impl_.clients_;
}

// -------------------------------------------------------------------

// S_OFFICE_REMOVE_WAITING_CLIENT

// repeated string clients = 1;
inline int S_OFFICE_REMOVE_WAITING_CLIENT::_internal_clients_size() const {
  return _impl_.clients_.size();
}
inline int S_OFFICE_REMOVE_WAITING_CLIENT::clients_size() const {
  return _internal_clients_size();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::clear_clients() {
  _impl_.clients_.Clear();
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT::add_clients() {
  std::string* _s = _internal_add_clients();
  // @@protoc_insertion_point(field_add_mutable:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _s;
}
inline const std::string& S_OFFICE_REMOVE_WAITING_CLIENT::_internal_clients(int index) const {
  return _impl_.clients_.Get(index);
}
inline const std::string& S_OFFICE_REMOVE_WAITING_CLIENT::clients(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _internal_clients(index);
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _impl_.clients_.Mutable(index);
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::set_clients(int index, const std::string& value) {
  _impl_.clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::set_clients(int index, std::string&& value) {
  _impl_.clients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::set_clients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::set_clients(int index, const char* value, size_t size) {
  _impl_.clients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT::_internal_add_clients() {
  return _impl_.clients_.Add();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::add_clients(const std::string& value) {
  _impl_.clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::add_clients(std::string&& value) {
  _impl_.clients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::add_clients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::add_clients(const char* value, size_t size) {
  _impl_.clients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
S_OFFICE_REMOVE_WAITING_CLIENT::clients() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _impl_.clients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
S_OFFICE_REMOVE_WAITING_CLIENT::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return &_impl_.clients_;
}

// -------------------------------------------------------------------

// C_OFFICE_ACCEPT_WAIT

// string clientId = 1;
inline void C_OFFICE_ACCEPT_WAIT::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_ACCEPT_WAIT::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_ACCEPT_WAIT::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline std::string* C_OFFICE_ACCEPT_WAIT::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _s;
}
inline const std::string& C_OFFICE_ACCEPT_WAIT::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_ACCEPT_WAIT::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_ACCEPT_WAIT::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_ACCEPT_WAIT::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_ACCEPT_WAIT::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}

// bool isAccepted = 2;
inline void C_OFFICE_ACCEPT_WAIT::clear_isaccepted() {
  _impl_.isaccepted_ = false;
}
inline bool C_OFFICE_ACCEPT_WAIT::_internal_isaccepted() const {
  return _impl_.isaccepted_;
}
inline bool C_OFFICE_ACCEPT_WAIT::isaccepted() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_ACCEPT_WAIT.isAccepted)
  return _internal_isaccepted();
}
inline void C_OFFICE_ACCEPT_WAIT::_internal_set_isaccepted(bool value) {
  
  _impl_.isaccepted_ = value;
}
inline void C_OFFICE_ACCEPT_WAIT::set_isaccepted(bool value) {
  _internal_set_isaccepted(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_ACCEPT_WAIT.isAccepted)
}

// -------------------------------------------------------------------

// S_OFFICE_ACCEPT_WAIT

// bool success = 1;
inline void S_OFFICE_ACCEPT_WAIT::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_ACCEPT_WAIT::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_ACCEPT_WAIT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ACCEPT_WAIT.success)
  return _internal_success();
}
inline void S_OFFICE_ACCEPT_WAIT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_ACCEPT_WAIT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ACCEPT_WAIT.success)
}

// -------------------------------------------------------------------

// S_OFFICE_ACCEPT_WAIT_NOTICE

// bool isAccepted = 1;
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::clear_isaccepted() {
  _impl_.isaccepted_ = false;
}
inline bool S_OFFICE_ACCEPT_WAIT_NOTICE::_internal_isaccepted() const {
  return _impl_.isaccepted_;
}
inline bool S_OFFICE_ACCEPT_WAIT_NOTICE::isaccepted() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE.isAccepted)
  return _internal_isaccepted();
}
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::_internal_set_isaccepted(bool value) {
  
  _impl_.isaccepted_ = value;
}
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::set_isaccepted(bool value) {
  _internal_set_isaccepted(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE.isAccepted)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_HOST

// -------------------------------------------------------------------

// S_OFFICE_GET_HOST

// string clientId = 1;
inline void S_OFFICE_GET_HOST::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_HOST::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_HOST.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_HOST::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_HOST.clientId)
}
inline std::string* S_OFFICE_GET_HOST::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_HOST.clientId)
  return _s;
}
inline const std::string& S_OFFICE_GET_HOST::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_OFFICE_GET_HOST::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_HOST::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_HOST::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_HOST.clientId)
  return _impl_.clientid_.Release();
}
inline void S_OFFICE_GET_HOST::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_HOST.clientId)
}

// -------------------------------------------------------------------

// C_OFFICE_BREAK

// -------------------------------------------------------------------

// S_OFFICE_BREAK

// bool success = 1;
inline void S_OFFICE_BREAK::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_BREAK::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_BREAK::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_BREAK.success)
  return _internal_success();
}
inline void S_OFFICE_BREAK::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_BREAK::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_BREAK.success)
}

// -------------------------------------------------------------------

// C_OFFICE_KICK

// string clientId = 1;
inline void C_OFFICE_KICK::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_KICK::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_KICK.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_KICK::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_KICK.clientId)
}
inline std::string* C_OFFICE_KICK::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_KICK.clientId)
  return _s;
}
inline const std::string& C_OFFICE_KICK::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_KICK::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_KICK::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_KICK::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_KICK.clientId)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_KICK::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_KICK.clientId)
}

// -------------------------------------------------------------------

// S_OFFICE_KICK

// bool success = 1;
inline void S_OFFICE_KICK::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_KICK::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_KICK::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_KICK.success)
  return _internal_success();
}
inline void S_OFFICE_KICK::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_KICK::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_KICK.success)
}

// -------------------------------------------------------------------

// USER_PERMISSION

// string clientId = 1;
inline void USER_PERMISSION::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& USER_PERMISSION::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER_PERMISSION::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.clientId)
}
inline std::string* USER_PERMISSION::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.USER_PERMISSION.clientId)
  return _s;
}
inline const std::string& USER_PERMISSION::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void USER_PERMISSION::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* USER_PERMISSION::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* USER_PERMISSION::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.USER_PERMISSION.clientId)
  return _impl_.clientid_.Release();
}
inline void USER_PERMISSION::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.USER_PERMISSION.clientId)
}

// bool screenPermission = 2;
inline void USER_PERMISSION::clear_screenpermission() {
  _impl_.screenpermission_ = false;
}
inline bool USER_PERMISSION::_internal_screenpermission() const {
  return _impl_.screenpermission_;
}
inline bool USER_PERMISSION::screenpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.screenPermission)
  return _internal_screenpermission();
}
inline void USER_PERMISSION::_internal_set_screenpermission(bool value) {
  
  _impl_.screenpermission_ = value;
}
inline void USER_PERMISSION::set_screenpermission(bool value) {
  _internal_set_screenpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.screenPermission)
}

// bool chatPermission = 3;
inline void USER_PERMISSION::clear_chatpermission() {
  _impl_.chatpermission_ = false;
}
inline bool USER_PERMISSION::_internal_chatpermission() const {
  return _impl_.chatpermission_;
}
inline bool USER_PERMISSION::chatpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.chatPermission)
  return _internal_chatpermission();
}
inline void USER_PERMISSION::_internal_set_chatpermission(bool value) {
  
  _impl_.chatpermission_ = value;
}
inline void USER_PERMISSION::set_chatpermission(bool value) {
  _internal_set_chatpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.chatPermission)
}

// bool voicePermission = 4;
inline void USER_PERMISSION::clear_voicepermission() {
  _impl_.voicepermission_ = false;
}
inline bool USER_PERMISSION::_internal_voicepermission() const {
  return _impl_.voicepermission_;
}
inline bool USER_PERMISSION::voicepermission() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.voicePermission)
  return _internal_voicepermission();
}
inline void USER_PERMISSION::_internal_set_voicepermission(bool value) {
  
  _impl_.voicepermission_ = value;
}
inline void USER_PERMISSION::set_voicepermission(bool value) {
  _internal_set_voicepermission(value);
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.voicePermission)
}

// bool videoPermission = 5;
inline void USER_PERMISSION::clear_videopermission() {
  _impl_.videopermission_ = false;
}
inline bool USER_PERMISSION::_internal_videopermission() const {
  return _impl_.videopermission_;
}
inline bool USER_PERMISSION::videopermission() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.videoPermission)
  return _internal_videopermission();
}
inline void USER_PERMISSION::_internal_set_videopermission(bool value) {
  
  _impl_.videopermission_ = value;
}
inline void USER_PERMISSION::set_videopermission(bool value) {
  _internal_set_videopermission(value);
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.videoPermission)
}

// int32 type = 6;
inline void USER_PERMISSION::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t USER_PERMISSION::_internal_type() const {
  return _impl_.type_;
}
inline int32_t USER_PERMISSION::type() const {
  // @@protoc_insertion_point(field_get:Protocol.USER_PERMISSION.type)
  return _internal_type();
}
inline void USER_PERMISSION::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void USER_PERMISSION::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.USER_PERMISSION.type)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_PERMISSION

// string clientId = 1;
inline void C_OFFICE_GET_PERMISSION::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_GET_PERMISSION::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_GET_PERMISSION::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_GET_PERMISSION.clientId)
}
inline std::string* C_OFFICE_GET_PERMISSION::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _s;
}
inline const std::string& C_OFFICE_GET_PERMISSION::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_GET_PERMISSION::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_GET_PERMISSION::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_GET_PERMISSION::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_GET_PERMISSION::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_GET_PERMISSION.clientId)
}

// -------------------------------------------------------------------

// S_OFFICE_GET_PERMISSION

// repeated .Protocol.USER_PERMISSION permissions = 1;
inline int S_OFFICE_GET_PERMISSION::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int S_OFFICE_GET_PERMISSION::permissions_size() const {
  return _internal_permissions_size();
}
inline void S_OFFICE_GET_PERMISSION::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::Protocol::USER_PERMISSION* S_OFFICE_GET_PERMISSION::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_PERMISSION.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >*
S_OFFICE_GET_PERMISSION::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_GET_PERMISSION.permissions)
  return &_impl_.permissions_;
}
inline const ::Protocol::USER_PERMISSION& S_OFFICE_GET_PERMISSION::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::Protocol::USER_PERMISSION& S_OFFICE_GET_PERMISSION::permissions(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_PERMISSION.permissions)
  return _internal_permissions(index);
}
inline ::Protocol::USER_PERMISSION* S_OFFICE_GET_PERMISSION::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::Protocol::USER_PERMISSION* S_OFFICE_GET_PERMISSION::add_permissions() {
  ::Protocol::USER_PERMISSION* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_GET_PERMISSION.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >&
S_OFFICE_GET_PERMISSION::permissions() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_GET_PERMISSION.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// C_OFFICE_SET_PERMISSION

// repeated .Protocol.USER_PERMISSION permissions = 1;
inline int C_OFFICE_SET_PERMISSION::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int C_OFFICE_SET_PERMISSION::permissions_size() const {
  return _internal_permissions_size();
}
inline void C_OFFICE_SET_PERMISSION::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::Protocol::USER_PERMISSION* C_OFFICE_SET_PERMISSION::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >*
C_OFFICE_SET_PERMISSION::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return &_impl_.permissions_;
}
inline const ::Protocol::USER_PERMISSION& C_OFFICE_SET_PERMISSION::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::Protocol::USER_PERMISSION& C_OFFICE_SET_PERMISSION::permissions(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _internal_permissions(index);
}
inline ::Protocol::USER_PERMISSION* C_OFFICE_SET_PERMISSION::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::Protocol::USER_PERMISSION* C_OFFICE_SET_PERMISSION::add_permissions() {
  ::Protocol::USER_PERMISSION* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::USER_PERMISSION >&
C_OFFICE_SET_PERMISSION::permissions() const {
  // @@protoc_insertion_point(field_list:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// S_OFFICE_SET_PERMISSION

// bool success = 1;
inline void S_OFFICE_SET_PERMISSION::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_SET_PERMISSION::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_SET_PERMISSION::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION.success)
  return _internal_success();
}
inline void S_OFFICE_SET_PERMISSION::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_SET_PERMISSION::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION.success)
}

// -------------------------------------------------------------------

// S_OFFICE_SET_PERMISSION_NOTICE

// bool screenPermission = 1;
inline void S_OFFICE_SET_PERMISSION_NOTICE::clear_screenpermission() {
  _impl_.screenpermission_ = false;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::_internal_screenpermission() const {
  return _impl_.screenpermission_;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::screenpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.screenPermission)
  return _internal_screenpermission();
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::_internal_set_screenpermission(bool value) {
  
  _impl_.screenpermission_ = value;
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::set_screenpermission(bool value) {
  _internal_set_screenpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.screenPermission)
}

// bool chatPermission = 2;
inline void S_OFFICE_SET_PERMISSION_NOTICE::clear_chatpermission() {
  _impl_.chatpermission_ = false;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::_internal_chatpermission() const {
  return _impl_.chatpermission_;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::chatpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.chatPermission)
  return _internal_chatpermission();
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::_internal_set_chatpermission(bool value) {
  
  _impl_.chatpermission_ = value;
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::set_chatpermission(bool value) {
  _internal_set_chatpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.chatPermission)
}

// bool voicePermission = 3;
inline void S_OFFICE_SET_PERMISSION_NOTICE::clear_voicepermission() {
  _impl_.voicepermission_ = false;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::_internal_voicepermission() const {
  return _impl_.voicepermission_;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::voicepermission() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.voicePermission)
  return _internal_voicepermission();
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::_internal_set_voicepermission(bool value) {
  
  _impl_.voicepermission_ = value;
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::set_voicepermission(bool value) {
  _internal_set_voicepermission(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.voicePermission)
}

// bool videoPermission = 4;
inline void S_OFFICE_SET_PERMISSION_NOTICE::clear_videopermission() {
  _impl_.videopermission_ = false;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::_internal_videopermission() const {
  return _impl_.videopermission_;
}
inline bool S_OFFICE_SET_PERMISSION_NOTICE::videopermission() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.videoPermission)
  return _internal_videopermission();
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::_internal_set_videopermission(bool value) {
  
  _impl_.videopermission_ = value;
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::set_videopermission(bool value) {
  _internal_set_videopermission(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.videoPermission)
}

// int32 type = 5;
inline void S_OFFICE_SET_PERMISSION_NOTICE::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t S_OFFICE_SET_PERMISSION_NOTICE::_internal_type() const {
  return _impl_.type_;
}
inline int32_t S_OFFICE_SET_PERMISSION_NOTICE::type() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.type)
  return _internal_type();
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void S_OFFICE_SET_PERMISSION_NOTICE::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION_NOTICE.type)
}

// -------------------------------------------------------------------

// C_OFFICE_SET_ROOM_INFO

// int32 personnel = 1;
inline void C_OFFICE_SET_ROOM_INFO::clear_personnel() {
  _impl_.personnel_ = 0;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::_internal_personnel() const {
  return _impl_.personnel_;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::personnel() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.personnel)
  return _internal_personnel();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_personnel(int32_t value) {
  
  _impl_.personnel_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_personnel(int32_t value) {
  _internal_set_personnel(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.personnel)
}

// string password = 2;
inline void C_OFFICE_SET_ROOM_INFO::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_SET_ROOM_INFO::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.password)
}
inline std::string* C_OFFICE_SET_ROOM_INFO::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _s;
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::_internal_password() const {
  return _impl_.password_.Get();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _impl_.password_.Release();
}
inline void C_OFFICE_SET_ROOM_INFO::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_SET_ROOM_INFO.password)
}

// bool isShutdown = 3;
inline void C_OFFICE_SET_ROOM_INFO::clear_isshutdown() {
  _impl_.isshutdown_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_isshutdown() const {
  return _impl_.isshutdown_;
}
inline bool C_OFFICE_SET_ROOM_INFO::isshutdown() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isShutdown)
  return _internal_isshutdown();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_isshutdown(bool value) {
  
  _impl_.isshutdown_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_isshutdown(bool value) {
  _internal_set_isshutdown(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isShutdown)
}

// bool isAdvertising = 4;
inline void C_OFFICE_SET_ROOM_INFO::clear_isadvertising() {
  _impl_.isadvertising_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_isadvertising() const {
  return _impl_.isadvertising_;
}
inline bool C_OFFICE_SET_ROOM_INFO::isadvertising() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isAdvertising)
  return _internal_isadvertising();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_isadvertising(bool value) {
  
  _impl_.isadvertising_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_isadvertising(bool value) {
  _internal_set_isadvertising(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isAdvertising)
}

// bool isWaitingRoom = 5;
inline void C_OFFICE_SET_ROOM_INFO::clear_iswaitingroom() {
  _impl_.iswaitingroom_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_iswaitingroom() const {
  return _impl_.iswaitingroom_;
}
inline bool C_OFFICE_SET_ROOM_INFO::iswaitingroom() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isWaitingRoom)
  return _internal_iswaitingroom();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_iswaitingroom(bool value) {
  
  _impl_.iswaitingroom_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_iswaitingroom(bool value) {
  _internal_set_iswaitingroom(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isWaitingRoom)
}

// -------------------------------------------------------------------

// S_OFFICE_SET_ROOM_INFO

// bool success = 1;
inline void S_OFFICE_SET_ROOM_INFO::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_SET_ROOM_INFO::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_SET_ROOM_INFO::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_ROOM_INFO.success)
  return _internal_success();
}
inline void S_OFFICE_SET_ROOM_INFO::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_SET_ROOM_INFO::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_ROOM_INFO.success)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_ROOM_INFO

// -------------------------------------------------------------------

// S_OFFICE_GET_ROOM_INFO

// string roomName = 1;
inline void S_OFFICE_GET_ROOM_INFO::clear_roomname() {
  _impl_.roomname_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::roomname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_roomname() const {
  return _impl_.roomname_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_roomname(const std::string& value) {
  
  _impl_.roomname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_roomname() {
  
  return _impl_.roomname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_roomname() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _impl_.roomname_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  _impl_.roomname_.SetAllocated(roomname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomname_.IsDefault()) {
    _impl_.roomname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
}

// string description = 2;
inline void S_OFFICE_GET_ROOM_INFO::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::description() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.description)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_description() const {
  return _impl_.description_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_description() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _impl_.description_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.description)
}

// int32 topicType = 3;
inline void S_OFFICE_GET_ROOM_INFO::clear_topictype() {
  _impl_.topictype_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_topictype() const {
  return _impl_.topictype_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::topictype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.topicType)
  return _internal_topictype();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_topictype(int32_t value) {
  
  _impl_.topictype_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_topictype(int32_t value) {
  _internal_set_topictype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.topicType)
}

// string password = 4;
inline void S_OFFICE_GET_ROOM_INFO::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::password() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.password)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_password() const {
  return _impl_.password_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _impl_.password_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.password)
}

// string spaceInfoId = 5;
inline void S_OFFICE_GET_ROOM_INFO::clear_spaceinfoid() {
  _impl_.spaceinfoid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::spaceinfoid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _internal_spaceinfoid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_spaceinfoid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceinfoid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_spaceinfoid() {
  std::string* _s = _internal_mutable_spaceinfoid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_spaceinfoid() const {
  return _impl_.spaceinfoid_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_spaceinfoid(const std::string& value) {
  
  _impl_.spaceinfoid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_spaceinfoid() {
  
  return _impl_.spaceinfoid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_spaceinfoid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _impl_.spaceinfoid_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_spaceinfoid(std::string* spaceinfoid) {
  if (spaceinfoid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceinfoid_.SetAllocated(spaceinfoid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceinfoid_.IsDefault()) {
    _impl_.spaceinfoid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
}

// int32 personnel = 6;
inline void S_OFFICE_GET_ROOM_INFO::clear_personnel() {
  _impl_.personnel_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_personnel() const {
  return _impl_.personnel_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::personnel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.personnel)
  return _internal_personnel();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_personnel(int32_t value) {
  
  _impl_.personnel_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_personnel(int32_t value) {
  _internal_set_personnel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.personnel)
}

// int32 currentPersonnel = 7;
inline void S_OFFICE_GET_ROOM_INFO::clear_currentpersonnel() {
  _impl_.currentpersonnel_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_currentpersonnel() const {
  return _impl_.currentpersonnel_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::currentpersonnel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.currentPersonnel)
  return _internal_currentpersonnel();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_currentpersonnel(int32_t value) {
  
  _impl_.currentpersonnel_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_currentpersonnel(int32_t value) {
  _internal_set_currentpersonnel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.currentPersonnel)
}

// bool isAdvertising = 8;
inline void S_OFFICE_GET_ROOM_INFO::clear_isadvertising() {
  _impl_.isadvertising_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_isadvertising() const {
  return _impl_.isadvertising_;
}
inline bool S_OFFICE_GET_ROOM_INFO::isadvertising() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isAdvertising)
  return _internal_isadvertising();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_isadvertising(bool value) {
  
  _impl_.isadvertising_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_isadvertising(bool value) {
  _internal_set_isadvertising(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isAdvertising)
}

// string thumbnail = 9;
inline void S_OFFICE_GET_ROOM_INFO::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::thumbnail() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_thumbnail(const std::string& value) {
  
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_thumbnail() {
  
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_thumbnail() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _impl_.thumbnail_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
}

// bool isWaitingRoom = 10;
inline void S_OFFICE_GET_ROOM_INFO::clear_iswaitingroom() {
  _impl_.iswaitingroom_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_iswaitingroom() const {
  return _impl_.iswaitingroom_;
}
inline bool S_OFFICE_GET_ROOM_INFO::iswaitingroom() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isWaitingRoom)
  return _internal_iswaitingroom();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_iswaitingroom(bool value) {
  
  _impl_.iswaitingroom_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_iswaitingroom(bool value) {
  _internal_set_iswaitingroom(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isWaitingRoom)
}

// bool isShutdown = 11;
inline void S_OFFICE_GET_ROOM_INFO::clear_isshutdown() {
  _impl_.isshutdown_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_isshutdown() const {
  return _impl_.isshutdown_;
}
inline bool S_OFFICE_GET_ROOM_INFO::isshutdown() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isShutdown)
  return _internal_isshutdown();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_isshutdown(bool value) {
  
  _impl_.isshutdown_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_isshutdown(bool value) {
  _internal_set_isshutdown(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isShutdown)
}

// int32 runningTime = 12;
inline void S_OFFICE_GET_ROOM_INFO::clear_runningtime() {
  _impl_.runningtime_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_runningtime() const {
  return _impl_.runningtime_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::runningtime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.runningTime)
  return _internal_runningtime();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_runningtime(int32_t value) {
  
  _impl_.runningtime_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_runningtime(int32_t value) {
  _internal_set_runningtime(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.runningTime)
}

// int32 passedTime = 13;
inline void S_OFFICE_GET_ROOM_INFO::clear_passedtime() {
  _impl_.passedtime_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_passedtime() const {
  return _impl_.passedtime_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::passedtime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.passedTime)
  return _internal_passedtime();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_passedtime(int32_t value) {
  
  _impl_.passedtime_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_passedtime(int32_t value) {
  _internal_set_passedtime(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.passedTime)
}

// string roomcode = 14;
inline void S_OFFICE_GET_ROOM_INFO::clear_roomcode() {
  _impl_.roomcode_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::roomcode() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _internal_roomcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_roomcode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_roomcode() {
  std::string* _s = _internal_mutable_roomcode();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_roomcode() const {
  return _impl_.roomcode_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_roomcode(const std::string& value) {
  
  _impl_.roomcode_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_roomcode() {
  
  return _impl_.roomcode_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_roomcode() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _impl_.roomcode_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_roomcode(std::string* roomcode) {
  if (roomcode != nullptr) {
    
  } else {
    
  }
  _impl_.roomcode_.SetAllocated(roomcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomcode_.IsDefault()) {
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
}

// string hostNickname = 15;
inline void S_OFFICE_GET_ROOM_INFO::clear_hostnickname() {
  _impl_.hostnickname_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::hostnickname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _internal_hostnickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_hostnickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostnickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_hostnickname() {
  std::string* _s = _internal_mutable_hostnickname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_hostnickname() const {
  return _impl_.hostnickname_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_hostnickname(const std::string& value) {
  
  _impl_.hostnickname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_hostnickname() {
  
  return _impl_.hostnickname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_hostnickname() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _impl_.hostnickname_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_hostnickname(std::string* hostnickname) {
  if (hostnickname != nullptr) {
    
  } else {
    
  }
  _impl_.hostnickname_.SetAllocated(hostnickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostnickname_.IsDefault()) {
    _impl_.hostnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
}

// -------------------------------------------------------------------

// C_OFFICE_VIDEO_STREAM

// string clientid = 1;
inline void C_OFFICE_VIDEO_STREAM::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_VIDEO_STREAM::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_VIDEO_STREAM::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
}
inline std::string* C_OFFICE_VIDEO_STREAM::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _s;
}
inline const std::string& C_OFFICE_VIDEO_STREAM::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_VIDEO_STREAM::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
}

// string url = 2;
inline void C_OFFICE_VIDEO_STREAM::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& C_OFFICE_VIDEO_STREAM::url() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_VIDEO_STREAM::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.url)
}
inline std::string* C_OFFICE_VIDEO_STREAM::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _s;
}
inline const std::string& C_OFFICE_VIDEO_STREAM::_internal_url() const {
  return _impl_.url_.Get();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::release_url() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _impl_.url_.Release();
}
inline void C_OFFICE_VIDEO_STREAM::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_VIDEO_STREAM.url)
}

// float volume = 3;
inline void C_OFFICE_VIDEO_STREAM::clear_volume() {
  _impl_.volume_ = 0;
}
inline float C_OFFICE_VIDEO_STREAM::_internal_volume() const {
  return _impl_.volume_;
}
inline float C_OFFICE_VIDEO_STREAM::volume() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.volume)
  return _internal_volume();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_volume(float value) {
  
  _impl_.volume_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.volume)
}

// float time = 4;
inline void C_OFFICE_VIDEO_STREAM::clear_time() {
  _impl_.time_ = 0;
}
inline float C_OFFICE_VIDEO_STREAM::_internal_time() const {
  return _impl_.time_;
}
inline float C_OFFICE_VIDEO_STREAM::time() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.time)
  return _internal_time();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.time)
}

// bool play = 5;
inline void C_OFFICE_VIDEO_STREAM::clear_play() {
  _impl_.play_ = false;
}
inline bool C_OFFICE_VIDEO_STREAM::_internal_play() const {
  return _impl_.play_;
}
inline bool C_OFFICE_VIDEO_STREAM::play() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.play)
  return _internal_play();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_play(bool value) {
  
  _impl_.play_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_play(bool value) {
  _internal_set_play(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.play)
}

// bool seek = 6;
inline void C_OFFICE_VIDEO_STREAM::clear_seek() {
  _impl_.seek_ = false;
}
inline bool C_OFFICE_VIDEO_STREAM::_internal_seek() const {
  return _impl_.seek_;
}
inline bool C_OFFICE_VIDEO_STREAM::seek() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.seek)
  return _internal_seek();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_seek(bool value) {
  
  _impl_.seek_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_seek(bool value) {
  _internal_set_seek(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.seek)
}

// int32 mediaPlayerState = 7;
inline void C_OFFICE_VIDEO_STREAM::clear_mediaplayerstate() {
  _impl_.mediaplayerstate_ = 0;
}
inline int32_t C_OFFICE_VIDEO_STREAM::_internal_mediaplayerstate() const {
  return _impl_.mediaplayerstate_;
}
inline int32_t C_OFFICE_VIDEO_STREAM::mediaplayerstate() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.mediaPlayerState)
  return _internal_mediaplayerstate();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_mediaplayerstate(int32_t value) {
  
  _impl_.mediaplayerstate_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_mediaplayerstate(int32_t value) {
  _internal_set_mediaplayerstate(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.mediaPlayerState)
}

// -------------------------------------------------------------------

// S_OFFICE_VIDEO_STREAM

// string url = 1;
inline void S_OFFICE_VIDEO_STREAM::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& S_OFFICE_VIDEO_STREAM::url() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_VIDEO_STREAM::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.url)
}
inline std::string* S_OFFICE_VIDEO_STREAM::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _s;
}
inline const std::string& S_OFFICE_VIDEO_STREAM::_internal_url() const {
  return _impl_.url_.Get();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::release_url() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _impl_.url_.Release();
}
inline void S_OFFICE_VIDEO_STREAM::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_VIDEO_STREAM.url)
}

// float volume = 2;
inline void S_OFFICE_VIDEO_STREAM::clear_volume() {
  _impl_.volume_ = 0;
}
inline float S_OFFICE_VIDEO_STREAM::_internal_volume() const {
  return _impl_.volume_;
}
inline float S_OFFICE_VIDEO_STREAM::volume() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.volume)
  return _internal_volume();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_volume(float value) {
  
  _impl_.volume_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.volume)
}

// float time = 3;
inline void S_OFFICE_VIDEO_STREAM::clear_time() {
  _impl_.time_ = 0;
}
inline float S_OFFICE_VIDEO_STREAM::_internal_time() const {
  return _impl_.time_;
}
inline float S_OFFICE_VIDEO_STREAM::time() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.time)
  return _internal_time();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.time)
}

// bool play = 4;
inline void S_OFFICE_VIDEO_STREAM::clear_play() {
  _impl_.play_ = false;
}
inline bool S_OFFICE_VIDEO_STREAM::_internal_play() const {
  return _impl_.play_;
}
inline bool S_OFFICE_VIDEO_STREAM::play() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.play)
  return _internal_play();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_play(bool value) {
  
  _impl_.play_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_play(bool value) {
  _internal_set_play(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.play)
}

// bool seek = 5;
inline void S_OFFICE_VIDEO_STREAM::clear_seek() {
  _impl_.seek_ = false;
}
inline bool S_OFFICE_VIDEO_STREAM::_internal_seek() const {
  return _impl_.seek_;
}
inline bool S_OFFICE_VIDEO_STREAM::seek() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.seek)
  return _internal_seek();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_seek(bool value) {
  
  _impl_.seek_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_seek(bool value) {
  _internal_set_seek(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.seek)
}

// int32 mediaPlayerState = 6;
inline void S_OFFICE_VIDEO_STREAM::clear_mediaplayerstate() {
  _impl_.mediaplayerstate_ = 0;
}
inline int32_t S_OFFICE_VIDEO_STREAM::_internal_mediaplayerstate() const {
  return _impl_.mediaplayerstate_;
}
inline int32_t S_OFFICE_VIDEO_STREAM::mediaplayerstate() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.mediaPlayerState)
  return _internal_mediaplayerstate();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_mediaplayerstate(int32_t value) {
  
  _impl_.mediaplayerstate_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_mediaplayerstate(int32_t value) {
  _internal_set_mediaplayerstate(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.mediaPlayerState)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto
