// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Packet_000_Common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Packet_5f000_5fCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Packet_5f000_5fCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Packet_5f000_5fCommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Packet_5f000_5fCommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Packet_5f000_5fCommon_2eproto;
namespace Protocol {
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_ENTER;
struct C_ENTERDefaultTypeInternal;
extern C_ENTERDefaultTypeInternal _C_ENTER_default_instance_;
class C_GET_CLIENT;
struct C_GET_CLIENTDefaultTypeInternal;
extern C_GET_CLIENTDefaultTypeInternal _C_GET_CLIENT_default_instance_;
class C_LEAVE;
struct C_LEAVEDefaultTypeInternal;
extern C_LEAVEDefaultTypeInternal _C_LEAVE_default_instance_;
class C_REENTER;
struct C_REENTERDefaultTypeInternal;
extern C_REENTERDefaultTypeInternal _C_REENTER_default_instance_;
class C_SET_NICKNAME;
struct C_SET_NICKNAMEDefaultTypeInternal;
extern C_SET_NICKNAMEDefaultTypeInternal _C_SET_NICKNAME_default_instance_;
class S_ADD_CLIENT;
struct S_ADD_CLIENTDefaultTypeInternal;
extern S_ADD_CLIENTDefaultTypeInternal _S_ADD_CLIENT_default_instance_;
class S_ADD_CLIENT_ClientInfo;
struct S_ADD_CLIENT_ClientInfoDefaultTypeInternal;
extern S_ADD_CLIENT_ClientInfoDefaultTypeInternal _S_ADD_CLIENT_ClientInfo_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_DISCONNECT;
struct S_DISCONNECTDefaultTypeInternal;
extern S_DISCONNECTDefaultTypeInternal _S_DISCONNECT_default_instance_;
class S_ENTER;
struct S_ENTERDefaultTypeInternal;
extern S_ENTERDefaultTypeInternal _S_ENTER_default_instance_;
class S_REENTER;
struct S_REENTERDefaultTypeInternal;
extern S_REENTERDefaultTypeInternal _S_REENTER_default_instance_;
class S_REMOVE_CLIENT;
struct S_REMOVE_CLIENTDefaultTypeInternal;
extern S_REMOVE_CLIENTDefaultTypeInternal _S_REMOVE_CLIENT_default_instance_;
class S_SET_NICKNAME;
struct S_SET_NICKNAMEDefaultTypeInternal;
extern S_SET_NICKNAMEDefaultTypeInternal _S_SET_NICKNAME_default_instance_;
class S_SET_NICKNAME_NOTICE;
struct S_SET_NICKNAME_NOTICEDefaultTypeInternal;
extern S_SET_NICKNAME_NOTICEDefaultTypeInternal _S_SET_NICKNAME_NOTICE_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_ENTER* Arena::CreateMaybeMessage<::Protocol::C_ENTER>(Arena*);
template<> ::Protocol::C_GET_CLIENT* Arena::CreateMaybeMessage<::Protocol::C_GET_CLIENT>(Arena*);
template<> ::Protocol::C_LEAVE* Arena::CreateMaybeMessage<::Protocol::C_LEAVE>(Arena*);
template<> ::Protocol::C_REENTER* Arena::CreateMaybeMessage<::Protocol::C_REENTER>(Arena*);
template<> ::Protocol::C_SET_NICKNAME* Arena::CreateMaybeMessage<::Protocol::C_SET_NICKNAME>(Arena*);
template<> ::Protocol::S_ADD_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_ADD_CLIENT>(Arena*);
template<> ::Protocol::S_ADD_CLIENT_ClientInfo* Arena::CreateMaybeMessage<::Protocol::S_ADD_CLIENT_ClientInfo>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_DISCONNECT* Arena::CreateMaybeMessage<::Protocol::S_DISCONNECT>(Arena*);
template<> ::Protocol::S_ENTER* Arena::CreateMaybeMessage<::Protocol::S_ENTER>(Arena*);
template<> ::Protocol::S_REENTER* Arena::CreateMaybeMessage<::Protocol::S_REENTER>(Arena*);
template<> ::Protocol::S_REMOVE_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_REMOVE_CLIENT>(Arena*);
template<> ::Protocol::S_SET_NICKNAME* Arena::CreateMaybeMessage<::Protocol::S_SET_NICKNAME>(Arena*);
template<> ::Protocol::S_SET_NICKNAME_NOTICE* Arena::CreateMaybeMessage<::Protocol::S_SET_NICKNAME_NOTICE>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_ENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER) */ {
 public:
  inline C_ENTER() : C_ENTER(nullptr) {}
  ~C_ENTER() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER(const C_ENTER& from);
  C_ENTER(C_ENTER&& from) noexcept
    : C_ENTER() {
    *this = ::std::move(from);
  }

  inline C_ENTER& operator=(const C_ENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER& operator=(C_ENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER* internal_default_instance() {
    return reinterpret_cast<const C_ENTER*>(
               &_C_ENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_ENTER& a, C_ENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER& from) {
    C_ENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER";
  }
  protected:
  explicit C_ENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kPasswordFieldNumber = 4,
    kSessionIdFieldNumber = 3,
    kIsObserverFieldNumber = 5,
  };
  // string roomId = 1;
  void clear_roomid();
  const std::string& roomid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomid();
  PROTOBUF_NODISCARD std::string* release_roomid();
  void set_allocated_roomid(std::string* roomid);
  private:
  const std::string& _internal_roomid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomid(const std::string& value);
  std::string* _internal_mutable_roomid();
  public:

  // string clientId = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 sessionId = 3;
  void clear_sessionid();
  int32_t sessionid() const;
  void set_sessionid(int32_t value);
  private:
  int32_t _internal_sessionid() const;
  void _internal_set_sessionid(int32_t value);
  public:

  // bool isObserver = 5;
  void clear_isobserver();
  bool isobserver() const;
  void set_isobserver(bool value);
  private:
  bool _internal_isobserver() const;
  void _internal_set_isobserver(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t sessionid_;
    bool isobserver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER) */ {
 public:
  inline S_ENTER() : S_ENTER(nullptr) {}
  ~S_ENTER() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER(const S_ENTER& from);
  S_ENTER(S_ENTER&& from) noexcept
    : S_ENTER() {
    *this = ::std::move(from);
  }

  inline S_ENTER& operator=(const S_ENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER& operator=(S_ENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER* internal_default_instance() {
    return reinterpret_cast<const S_ENTER*>(
               &_S_ENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_ENTER& a, S_ENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER& from) {
    S_ENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER";
  }
  protected:
  explicit S_ENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class C_REENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_REENTER) */ {
 public:
  inline C_REENTER() : C_REENTER(nullptr) {}
  ~C_REENTER() override;
  explicit PROTOBUF_CONSTEXPR C_REENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REENTER(const C_REENTER& from);
  C_REENTER(C_REENTER&& from) noexcept
    : C_REENTER() {
    *this = ::std::move(from);
  }

  inline C_REENTER& operator=(const C_REENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REENTER& operator=(C_REENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REENTER* internal_default_instance() {
    return reinterpret_cast<const C_REENTER*>(
               &_C_REENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_REENTER& a, C_REENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_REENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_REENTER& from) {
    C_REENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_REENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REENTER";
  }
  protected:
  explicit C_REENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_REENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_REENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_REENTER) */ {
 public:
  inline S_REENTER() : S_REENTER(nullptr) {}
  ~S_REENTER() override;
  explicit PROTOBUF_CONSTEXPR S_REENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REENTER(const S_REENTER& from);
  S_REENTER(S_REENTER&& from) noexcept
    : S_REENTER() {
    *this = ::std::move(from);
  }

  inline S_REENTER& operator=(const S_REENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REENTER& operator=(S_REENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REENTER* internal_default_instance() {
    return reinterpret_cast<const S_REENTER*>(
               &_S_REENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_REENTER& a, S_REENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_REENTER& from) {
    S_REENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_REENTER";
  }
  protected:
  explicit S_REENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_REENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE) */ {
 public:
  inline C_LEAVE() : C_LEAVE(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LEAVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE(const C_LEAVE& from);
  C_LEAVE(C_LEAVE&& from) noexcept
    : C_LEAVE() {
    *this = ::std::move(from);
  }

  inline C_LEAVE& operator=(const C_LEAVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE& operator=(C_LEAVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE*>(
               &_C_LEAVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_LEAVE& a, C_LEAVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LEAVE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LEAVE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE";
  }
  protected:
  explicit C_LEAVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class C_GET_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_GET_CLIENT) */ {
 public:
  inline C_GET_CLIENT() : C_GET_CLIENT(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_GET_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GET_CLIENT(const C_GET_CLIENT& from);
  C_GET_CLIENT(C_GET_CLIENT&& from) noexcept
    : C_GET_CLIENT() {
    *this = ::std::move(from);
  }

  inline C_GET_CLIENT& operator=(const C_GET_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GET_CLIENT& operator=(C_GET_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GET_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GET_CLIENT* internal_default_instance() {
    return reinterpret_cast<const C_GET_CLIENT*>(
               &_C_GET_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_GET_CLIENT& a, C_GET_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GET_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GET_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_GET_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_GET_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_GET_CLIENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_GET_CLIENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GET_CLIENT";
  }
  protected:
  explicit C_GET_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_GET_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_CLIENT_ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ADD_CLIENT.ClientInfo) */ {
 public:
  inline S_ADD_CLIENT_ClientInfo() : S_ADD_CLIENT_ClientInfo(nullptr) {}
  ~S_ADD_CLIENT_ClientInfo() override;
  explicit PROTOBUF_CONSTEXPR S_ADD_CLIENT_ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_CLIENT_ClientInfo(const S_ADD_CLIENT_ClientInfo& from);
  S_ADD_CLIENT_ClientInfo(S_ADD_CLIENT_ClientInfo&& from) noexcept
    : S_ADD_CLIENT_ClientInfo() {
    *this = ::std::move(from);
  }

  inline S_ADD_CLIENT_ClientInfo& operator=(const S_ADD_CLIENT_ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_CLIENT_ClientInfo& operator=(S_ADD_CLIENT_ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_CLIENT_ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_CLIENT_ClientInfo* internal_default_instance() {
    return reinterpret_cast<const S_ADD_CLIENT_ClientInfo*>(
               &_S_ADD_CLIENT_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_ADD_CLIENT_ClientInfo& a, S_ADD_CLIENT_ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_CLIENT_ClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_CLIENT_ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_CLIENT_ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_CLIENT_ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_CLIENT_ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ADD_CLIENT_ClientInfo& from) {
    S_ADD_CLIENT_ClientInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_CLIENT_ClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ADD_CLIENT.ClientInfo";
  }
  protected:
  explicit S_ADD_CLIENT_ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kStateMessageFieldNumber = 3,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string stateMessage = 3;
  void clear_statemessage();
  const std::string& statemessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statemessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statemessage();
  PROTOBUF_NODISCARD std::string* release_statemessage();
  void set_allocated_statemessage(std::string* statemessage);
  private:
  const std::string& _internal_statemessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statemessage(const std::string& value);
  std::string* _internal_mutable_statemessage();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ADD_CLIENT.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statemessage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ADD_CLIENT) */ {
 public:
  inline S_ADD_CLIENT() : S_ADD_CLIENT(nullptr) {}
  ~S_ADD_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_ADD_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_CLIENT(const S_ADD_CLIENT& from);
  S_ADD_CLIENT(S_ADD_CLIENT&& from) noexcept
    : S_ADD_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_ADD_CLIENT& operator=(const S_ADD_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_CLIENT& operator=(S_ADD_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_ADD_CLIENT*>(
               &_S_ADD_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_ADD_CLIENT& a, S_ADD_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ADD_CLIENT& from) {
    S_ADD_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ADD_CLIENT";
  }
  protected:
  explicit S_ADD_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef S_ADD_CLIENT_ClientInfo ClientInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kClientInfosFieldNumber = 1,
  };
  // repeated .Protocol.S_ADD_CLIENT.ClientInfo clientInfos = 1;
  int clientinfos_size() const;
  private:
  int _internal_clientinfos_size() const;
  public:
  void clear_clientinfos();
  ::Protocol::S_ADD_CLIENT_ClientInfo* mutable_clientinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_ADD_CLIENT_ClientInfo >*
      mutable_clientinfos();
  private:
  const ::Protocol::S_ADD_CLIENT_ClientInfo& _internal_clientinfos(int index) const;
  ::Protocol::S_ADD_CLIENT_ClientInfo* _internal_add_clientinfos();
  public:
  const ::Protocol::S_ADD_CLIENT_ClientInfo& clientinfos(int index) const;
  ::Protocol::S_ADD_CLIENT_ClientInfo* add_clientinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_ADD_CLIENT_ClientInfo >&
      clientinfos() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ADD_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_ADD_CLIENT_ClientInfo > clientinfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_REMOVE_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_REMOVE_CLIENT) */ {
 public:
  inline S_REMOVE_CLIENT() : S_REMOVE_CLIENT(nullptr) {}
  ~S_REMOVE_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_REMOVE_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REMOVE_CLIENT(const S_REMOVE_CLIENT& from);
  S_REMOVE_CLIENT(S_REMOVE_CLIENT&& from) noexcept
    : S_REMOVE_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_REMOVE_CLIENT& operator=(const S_REMOVE_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REMOVE_CLIENT& operator=(S_REMOVE_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REMOVE_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REMOVE_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_REMOVE_CLIENT*>(
               &_S_REMOVE_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_REMOVE_CLIENT& a, S_REMOVE_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REMOVE_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REMOVE_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REMOVE_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REMOVE_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REMOVE_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_REMOVE_CLIENT& from) {
    S_REMOVE_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REMOVE_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_REMOVE_CLIENT";
  }
  protected:
  explicit S_REMOVE_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 1,
  };
  // repeated string clientIds = 1;
  int clientids_size() const;
  private:
  int _internal_clientids_size() const;
  public:
  void clear_clientids();
  const std::string& clientids(int index) const;
  std::string* mutable_clientids(int index);
  void set_clientids(int index, const std::string& value);
  void set_clientids(int index, std::string&& value);
  void set_clientids(int index, const char* value);
  void set_clientids(int index, const char* value, size_t size);
  std::string* add_clientids();
  void add_clientids(const std::string& value);
  void add_clientids(std::string&& value);
  void add_clientids(const char* value);
  void add_clientids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clientids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clientids();
  private:
  const std::string& _internal_clientids(int index) const;
  std::string* _internal_add_clientids();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_REMOVE_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clientids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class C_SET_NICKNAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SET_NICKNAME) */ {
 public:
  inline C_SET_NICKNAME() : C_SET_NICKNAME(nullptr) {}
  ~C_SET_NICKNAME() override;
  explicit PROTOBUF_CONSTEXPR C_SET_NICKNAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SET_NICKNAME(const C_SET_NICKNAME& from);
  C_SET_NICKNAME(C_SET_NICKNAME&& from) noexcept
    : C_SET_NICKNAME() {
    *this = ::std::move(from);
  }

  inline C_SET_NICKNAME& operator=(const C_SET_NICKNAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SET_NICKNAME& operator=(C_SET_NICKNAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SET_NICKNAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SET_NICKNAME* internal_default_instance() {
    return reinterpret_cast<const C_SET_NICKNAME*>(
               &_C_SET_NICKNAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_SET_NICKNAME& a, C_SET_NICKNAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SET_NICKNAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SET_NICKNAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SET_NICKNAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SET_NICKNAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SET_NICKNAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SET_NICKNAME& from) {
    C_SET_NICKNAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SET_NICKNAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SET_NICKNAME";
  }
  protected:
  explicit C_SET_NICKNAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SET_NICKNAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_SET_NICKNAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SET_NICKNAME) */ {
 public:
  inline S_SET_NICKNAME() : S_SET_NICKNAME(nullptr) {}
  ~S_SET_NICKNAME() override;
  explicit PROTOBUF_CONSTEXPR S_SET_NICKNAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SET_NICKNAME(const S_SET_NICKNAME& from);
  S_SET_NICKNAME(S_SET_NICKNAME&& from) noexcept
    : S_SET_NICKNAME() {
    *this = ::std::move(from);
  }

  inline S_SET_NICKNAME& operator=(const S_SET_NICKNAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SET_NICKNAME& operator=(S_SET_NICKNAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SET_NICKNAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SET_NICKNAME* internal_default_instance() {
    return reinterpret_cast<const S_SET_NICKNAME*>(
               &_S_SET_NICKNAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_SET_NICKNAME& a, S_SET_NICKNAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SET_NICKNAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SET_NICKNAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SET_NICKNAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SET_NICKNAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SET_NICKNAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SET_NICKNAME& from) {
    S_SET_NICKNAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SET_NICKNAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SET_NICKNAME";
  }
  protected:
  explicit S_SET_NICKNAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SET_NICKNAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_SET_NICKNAME_NOTICE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SET_NICKNAME_NOTICE) */ {
 public:
  inline S_SET_NICKNAME_NOTICE() : S_SET_NICKNAME_NOTICE(nullptr) {}
  ~S_SET_NICKNAME_NOTICE() override;
  explicit PROTOBUF_CONSTEXPR S_SET_NICKNAME_NOTICE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SET_NICKNAME_NOTICE(const S_SET_NICKNAME_NOTICE& from);
  S_SET_NICKNAME_NOTICE(S_SET_NICKNAME_NOTICE&& from) noexcept
    : S_SET_NICKNAME_NOTICE() {
    *this = ::std::move(from);
  }

  inline S_SET_NICKNAME_NOTICE& operator=(const S_SET_NICKNAME_NOTICE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SET_NICKNAME_NOTICE& operator=(S_SET_NICKNAME_NOTICE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SET_NICKNAME_NOTICE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SET_NICKNAME_NOTICE* internal_default_instance() {
    return reinterpret_cast<const S_SET_NICKNAME_NOTICE*>(
               &_S_SET_NICKNAME_NOTICE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_SET_NICKNAME_NOTICE& a, S_SET_NICKNAME_NOTICE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SET_NICKNAME_NOTICE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SET_NICKNAME_NOTICE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SET_NICKNAME_NOTICE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SET_NICKNAME_NOTICE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SET_NICKNAME_NOTICE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SET_NICKNAME_NOTICE& from) {
    S_SET_NICKNAME_NOTICE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SET_NICKNAME_NOTICE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SET_NICKNAME_NOTICE";
  }
  protected:
  explicit S_SET_NICKNAME_NOTICE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SET_NICKNAME_NOTICE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 1,
  };
  // string chat = 1;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kChatFieldNumber = 2,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string chat = 2;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// -------------------------------------------------------------------

class S_DISCONNECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DISCONNECT) */ {
 public:
  inline S_DISCONNECT() : S_DISCONNECT(nullptr) {}
  ~S_DISCONNECT() override;
  explicit PROTOBUF_CONSTEXPR S_DISCONNECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DISCONNECT(const S_DISCONNECT& from);
  S_DISCONNECT(S_DISCONNECT&& from) noexcept
    : S_DISCONNECT() {
    *this = ::std::move(from);
  }

  inline S_DISCONNECT& operator=(const S_DISCONNECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DISCONNECT& operator=(S_DISCONNECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DISCONNECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DISCONNECT* internal_default_instance() {
    return reinterpret_cast<const S_DISCONNECT*>(
               &_S_DISCONNECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_DISCONNECT& a, S_DISCONNECT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DISCONNECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DISCONNECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DISCONNECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DISCONNECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DISCONNECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DISCONNECT& from) {
    S_DISCONNECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DISCONNECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DISCONNECT";
  }
  protected:
  explicit S_DISCONNECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DISCONNECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f000_5fCommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_ENTER

// string roomId = 1;
inline void C_ENTER::clear_roomid() {
  _impl_.roomid_.ClearToEmpty();
}
inline const std::string& C_ENTER::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.roomId)
  return _internal_roomid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_ENTER::set_roomid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.roomId)
}
inline std::string* C_ENTER::mutable_roomid() {
  std::string* _s = _internal_mutable_roomid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER.roomId)
  return _s;
}
inline const std::string& C_ENTER::_internal_roomid() const {
  return _impl_.roomid_.Get();
}
inline void C_ENTER::_internal_set_roomid(const std::string& value) {
  
  _impl_.roomid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_ENTER::_internal_mutable_roomid() {
  
  return _impl_.roomid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_ENTER::release_roomid() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER.roomId)
  return _impl_.roomid_.Release();
}
inline void C_ENTER::set_allocated_roomid(std::string* roomid) {
  if (roomid != nullptr) {
    
  } else {
    
  }
  _impl_.roomid_.SetAllocated(roomid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomid_.IsDefault()) {
    _impl_.roomid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER.roomId)
}

// string clientId = 2;
inline void C_ENTER::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_ENTER::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_ENTER::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.clientId)
}
inline std::string* C_ENTER::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER.clientId)
  return _s;
}
inline const std::string& C_ENTER::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_ENTER::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_ENTER::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_ENTER::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER.clientId)
  return _impl_.clientid_.Release();
}
inline void C_ENTER::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER.clientId)
}

// int32 sessionId = 3;
inline void C_ENTER::clear_sessionid() {
  _impl_.sessionid_ = 0;
}
inline int32_t C_ENTER::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline int32_t C_ENTER::sessionid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.sessionId)
  return _internal_sessionid();
}
inline void C_ENTER::_internal_set_sessionid(int32_t value) {
  
  _impl_.sessionid_ = value;
}
inline void C_ENTER::set_sessionid(int32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.sessionId)
}

// string password = 4;
inline void C_ENTER::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& C_ENTER::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_ENTER::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.password)
}
inline std::string* C_ENTER::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER.password)
  return _s;
}
inline const std::string& C_ENTER::_internal_password() const {
  return _impl_.password_.Get();
}
inline void C_ENTER::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* C_ENTER::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* C_ENTER::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER.password)
  return _impl_.password_.Release();
}
inline void C_ENTER::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER.password)
}

// bool isObserver = 5;
inline void C_ENTER::clear_isobserver() {
  _impl_.isobserver_ = false;
}
inline bool C_ENTER::_internal_isobserver() const {
  return _impl_.isobserver_;
}
inline bool C_ENTER::isobserver() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.isObserver)
  return _internal_isobserver();
}
inline void C_ENTER::_internal_set_isobserver(bool value) {
  
  _impl_.isobserver_ = value;
}
inline void C_ENTER::set_isobserver(bool value) {
  _internal_set_isobserver(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.isObserver)
}

// -------------------------------------------------------------------

// S_ENTER

// string result = 1;
inline void S_ENTER::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& S_ENTER::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ENTER::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER.result)
}
inline std::string* S_ENTER::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER.result)
  return _s;
}
inline const std::string& S_ENTER::_internal_result() const {
  return _impl_.result_.Get();
}
inline void S_ENTER::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ENTER::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ENTER::release_result() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER.result)
  return _impl_.result_.Release();
}
inline void S_ENTER::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER.result)
}

// -------------------------------------------------------------------

// C_REENTER

// string clientId = 1;
inline void C_REENTER::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_REENTER::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_REENTER.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_REENTER::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_REENTER.clientId)
}
inline std::string* C_REENTER::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_REENTER.clientId)
  return _s;
}
inline const std::string& C_REENTER::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_REENTER::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_REENTER::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_REENTER::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_REENTER.clientId)
  return _impl_.clientid_.Release();
}
inline void C_REENTER::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_REENTER.clientId)
}

// -------------------------------------------------------------------

// S_REENTER

// bool success = 1;
inline void S_REENTER::clear_success() {
  _impl_.success_ = false;
}
inline bool S_REENTER::_internal_success() const {
  return _impl_.success_;
}
inline bool S_REENTER::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_REENTER.success)
  return _internal_success();
}
inline void S_REENTER::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_REENTER::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_REENTER.success)
}

// -------------------------------------------------------------------

// C_LEAVE

// -------------------------------------------------------------------

// C_GET_CLIENT

// -------------------------------------------------------------------

// S_ADD_CLIENT_ClientInfo

// string clientId = 1;
inline void S_ADD_CLIENT_ClientInfo::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_ADD_CLIENT_ClientInfo::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_CLIENT.ClientInfo.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ADD_CLIENT_ClientInfo::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ADD_CLIENT.ClientInfo.clientId)
}
inline std::string* S_ADD_CLIENT_ClientInfo::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_CLIENT.ClientInfo.clientId)
  return _s;
}
inline const std::string& S_ADD_CLIENT_ClientInfo::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_ADD_CLIENT_ClientInfo::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_ADD_CLIENT.ClientInfo.clientId)
  return _impl_.clientid_.Release();
}
inline void S_ADD_CLIENT_ClientInfo::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ADD_CLIENT.ClientInfo.clientId)
}

// string nickname = 2;
inline void S_ADD_CLIENT_ClientInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& S_ADD_CLIENT_ClientInfo::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_CLIENT.ClientInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ADD_CLIENT_ClientInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ADD_CLIENT.ClientInfo.nickname)
}
inline std::string* S_ADD_CLIENT_ClientInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_CLIENT.ClientInfo.nickname)
  return _s;
}
inline const std::string& S_ADD_CLIENT_ClientInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void S_ADD_CLIENT_ClientInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.S_ADD_CLIENT.ClientInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void S_ADD_CLIENT_ClientInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ADD_CLIENT.ClientInfo.nickname)
}

// string stateMessage = 3;
inline void S_ADD_CLIENT_ClientInfo::clear_statemessage() {
  _impl_.statemessage_.ClearToEmpty();
}
inline const std::string& S_ADD_CLIENT_ClientInfo::statemessage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_CLIENT.ClientInfo.stateMessage)
  return _internal_statemessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ADD_CLIENT_ClientInfo::set_statemessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statemessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ADD_CLIENT.ClientInfo.stateMessage)
}
inline std::string* S_ADD_CLIENT_ClientInfo::mutable_statemessage() {
  std::string* _s = _internal_mutable_statemessage();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_CLIENT.ClientInfo.stateMessage)
  return _s;
}
inline const std::string& S_ADD_CLIENT_ClientInfo::_internal_statemessage() const {
  return _impl_.statemessage_.Get();
}
inline void S_ADD_CLIENT_ClientInfo::_internal_set_statemessage(const std::string& value) {
  
  _impl_.statemessage_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::_internal_mutable_statemessage() {
  
  return _impl_.statemessage_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ADD_CLIENT_ClientInfo::release_statemessage() {
  // @@protoc_insertion_point(field_release:Protocol.S_ADD_CLIENT.ClientInfo.stateMessage)
  return _impl_.statemessage_.Release();
}
inline void S_ADD_CLIENT_ClientInfo::set_allocated_statemessage(std::string* statemessage) {
  if (statemessage != nullptr) {
    
  } else {
    
  }
  _impl_.statemessage_.SetAllocated(statemessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statemessage_.IsDefault()) {
    _impl_.statemessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ADD_CLIENT.ClientInfo.stateMessage)
}

// -------------------------------------------------------------------

// S_ADD_CLIENT

// repeated .Protocol.S_ADD_CLIENT.ClientInfo clientInfos = 1;
inline int S_ADD_CLIENT::_internal_clientinfos_size() const {
  return _impl_.clientinfos_.size();
}
inline int S_ADD_CLIENT::clientinfos_size() const {
  return _internal_clientinfos_size();
}
inline void S_ADD_CLIENT::clear_clientinfos() {
  _impl_.clientinfos_.Clear();
}
inline ::Protocol::S_ADD_CLIENT_ClientInfo* S_ADD_CLIENT::mutable_clientinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_CLIENT.clientInfos)
  return _impl_.clientinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_ADD_CLIENT_ClientInfo >*
S_ADD_CLIENT::mutable_clientinfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ADD_CLIENT.clientInfos)
  return &_impl_.clientinfos_;
}
inline const ::Protocol::S_ADD_CLIENT_ClientInfo& S_ADD_CLIENT::_internal_clientinfos(int index) const {
  return _impl_.clientinfos_.Get(index);
}
inline const ::Protocol::S_ADD_CLIENT_ClientInfo& S_ADD_CLIENT::clientinfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_CLIENT.clientInfos)
  return _internal_clientinfos(index);
}
inline ::Protocol::S_ADD_CLIENT_ClientInfo* S_ADD_CLIENT::_internal_add_clientinfos() {
  return _impl_.clientinfos_.Add();
}
inline ::Protocol::S_ADD_CLIENT_ClientInfo* S_ADD_CLIENT::add_clientinfos() {
  ::Protocol::S_ADD_CLIENT_ClientInfo* _add = _internal_add_clientinfos();
  // @@protoc_insertion_point(field_add:Protocol.S_ADD_CLIENT.clientInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_ADD_CLIENT_ClientInfo >&
S_ADD_CLIENT::clientinfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ADD_CLIENT.clientInfos)
  return _impl_.clientinfos_;
}

// -------------------------------------------------------------------

// S_REMOVE_CLIENT

// repeated string clientIds = 1;
inline int S_REMOVE_CLIENT::_internal_clientids_size() const {
  return _impl_.clientids_.size();
}
inline int S_REMOVE_CLIENT::clientids_size() const {
  return _internal_clientids_size();
}
inline void S_REMOVE_CLIENT::clear_clientids() {
  _impl_.clientids_.Clear();
}
inline std::string* S_REMOVE_CLIENT::add_clientids() {
  std::string* _s = _internal_add_clientids();
  // @@protoc_insertion_point(field_add_mutable:Protocol.S_REMOVE_CLIENT.clientIds)
  return _s;
}
inline const std::string& S_REMOVE_CLIENT::_internal_clientids(int index) const {
  return _impl_.clientids_.Get(index);
}
inline const std::string& S_REMOVE_CLIENT::clientids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_REMOVE_CLIENT.clientIds)
  return _internal_clientids(index);
}
inline std::string* S_REMOVE_CLIENT::mutable_clientids(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_REMOVE_CLIENT.clientIds)
  return _impl_.clientids_.Mutable(index);
}
inline void S_REMOVE_CLIENT::set_clientids(int index, const std::string& value) {
  _impl_.clientids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::set_clientids(int index, std::string&& value) {
  _impl_.clientids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::set_clientids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clientids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::set_clientids(int index, const char* value, size_t size) {
  _impl_.clientids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline std::string* S_REMOVE_CLIENT::_internal_add_clientids() {
  return _impl_.clientids_.Add();
}
inline void S_REMOVE_CLIENT::add_clientids(const std::string& value) {
  _impl_.clientids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::add_clientids(std::string&& value) {
  _impl_.clientids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::add_clientids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clientids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline void S_REMOVE_CLIENT::add_clientids(const char* value, size_t size) {
  _impl_.clientids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Protocol.S_REMOVE_CLIENT.clientIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
S_REMOVE_CLIENT::clientids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_REMOVE_CLIENT.clientIds)
  return _impl_.clientids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
S_REMOVE_CLIENT::mutable_clientids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_REMOVE_CLIENT.clientIds)
  return &_impl_.clientids_;
}

// -------------------------------------------------------------------

// C_SET_NICKNAME

// string nickname = 1;
inline void C_SET_NICKNAME::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& C_SET_NICKNAME::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_NICKNAME.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SET_NICKNAME::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SET_NICKNAME.nickname)
}
inline std::string* C_SET_NICKNAME::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SET_NICKNAME.nickname)
  return _s;
}
inline const std::string& C_SET_NICKNAME::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void C_SET_NICKNAME::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* C_SET_NICKNAME::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* C_SET_NICKNAME::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.C_SET_NICKNAME.nickname)
  return _impl_.nickname_.Release();
}
inline void C_SET_NICKNAME::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SET_NICKNAME.nickname)
}

// -------------------------------------------------------------------

// S_SET_NICKNAME

// bool success = 1;
inline void S_SET_NICKNAME::clear_success() {
  _impl_.success_ = false;
}
inline bool S_SET_NICKNAME::_internal_success() const {
  return _impl_.success_;
}
inline bool S_SET_NICKNAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_NICKNAME.success)
  return _internal_success();
}
inline void S_SET_NICKNAME::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_SET_NICKNAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_NICKNAME.success)
}

// -------------------------------------------------------------------

// S_SET_NICKNAME_NOTICE

// string clientId = 1;
inline void S_SET_NICKNAME_NOTICE::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_SET_NICKNAME_NOTICE::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_NICKNAME_NOTICE.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_SET_NICKNAME_NOTICE::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_SET_NICKNAME_NOTICE.clientId)
}
inline std::string* S_SET_NICKNAME_NOTICE::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SET_NICKNAME_NOTICE.clientId)
  return _s;
}
inline const std::string& S_SET_NICKNAME_NOTICE::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_SET_NICKNAME_NOTICE::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_SET_NICKNAME_NOTICE::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_SET_NICKNAME_NOTICE::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_SET_NICKNAME_NOTICE.clientId)
  return _impl_.clientid_.Release();
}
inline void S_SET_NICKNAME_NOTICE::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SET_NICKNAME_NOTICE.clientId)
}

// string nickname = 2;
inline void S_SET_NICKNAME_NOTICE::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& S_SET_NICKNAME_NOTICE::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_NICKNAME_NOTICE.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_SET_NICKNAME_NOTICE::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_SET_NICKNAME_NOTICE.nickname)
}
inline std::string* S_SET_NICKNAME_NOTICE::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SET_NICKNAME_NOTICE.nickname)
  return _s;
}
inline const std::string& S_SET_NICKNAME_NOTICE::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void S_SET_NICKNAME_NOTICE::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_SET_NICKNAME_NOTICE::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_SET_NICKNAME_NOTICE::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.S_SET_NICKNAME_NOTICE.nickname)
  return _impl_.nickname_.Release();
}
inline void S_SET_NICKNAME_NOTICE::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SET_NICKNAME_NOTICE.nickname)
}

// -------------------------------------------------------------------

// C_CHAT

// string chat = 1;
inline void C_CHAT::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& C_CHAT::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.chat)
}
inline std::string* C_CHAT::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.chat)
  return _s;
}
inline const std::string& C_CHAT::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void C_CHAT::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.chat)
  return _impl_.chat_.Release();
}
inline void C_CHAT::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.chat)
}

// -------------------------------------------------------------------

// S_CHAT

// string clientId = 1;
inline void S_CHAT::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_CHAT::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.clientId)
}
inline std::string* S_CHAT::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.clientId)
  return _s;
}
inline const std::string& S_CHAT::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_CHAT::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.clientId)
  return _impl_.clientid_.Release();
}
inline void S_CHAT::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.clientId)
}

// string chat = 2;
inline void S_CHAT::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& S_CHAT::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.chat)
}
inline std::string* S_CHAT::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.chat)
  return _s;
}
inline const std::string& S_CHAT::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void S_CHAT::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.chat)
  return _impl_.chat_.Release();
}
inline void S_CHAT::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.chat)
}

// -------------------------------------------------------------------

// S_DISCONNECT

// string code = 1;
inline void S_DISCONNECT::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& S_DISCONNECT::code() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DISCONNECT.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_DISCONNECT::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_DISCONNECT.code)
}
inline std::string* S_DISCONNECT::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:Protocol.S_DISCONNECT.code)
  return _s;
}
inline const std::string& S_DISCONNECT::_internal_code() const {
  return _impl_.code_.Get();
}
inline void S_DISCONNECT::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* S_DISCONNECT::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* S_DISCONNECT::release_code() {
  // @@protoc_insertion_point(field_release:Protocol.S_DISCONNECT.code)
  return _impl_.code_.Release();
}
inline void S_DISCONNECT::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_DISCONNECT.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Packet_5f000_5fCommon_2eproto
