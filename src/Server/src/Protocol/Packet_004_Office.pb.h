// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Packet_004_Office.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Packet_5f004_5fOffice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Packet_5f004_5fOffice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Packet_5f004_5fOffice_2eproto;
namespace Protocol {
class C_OFFICE_ACCEPT_WAIT;
struct C_OFFICE_ACCEPT_WAITDefaultTypeInternal;
extern C_OFFICE_ACCEPT_WAITDefaultTypeInternal _C_OFFICE_ACCEPT_WAIT_default_instance_;
class C_OFFICE_BREAK;
struct C_OFFICE_BREAKDefaultTypeInternal;
extern C_OFFICE_BREAKDefaultTypeInternal _C_OFFICE_BREAK_default_instance_;
class C_OFFICE_GET_HOST;
struct C_OFFICE_GET_HOSTDefaultTypeInternal;
extern C_OFFICE_GET_HOSTDefaultTypeInternal _C_OFFICE_GET_HOST_default_instance_;
class C_OFFICE_GET_PERMISSION;
struct C_OFFICE_GET_PERMISSIONDefaultTypeInternal;
extern C_OFFICE_GET_PERMISSIONDefaultTypeInternal _C_OFFICE_GET_PERMISSION_default_instance_;
class C_OFFICE_GET_PERMISSION_ALL;
struct C_OFFICE_GET_PERMISSION_ALLDefaultTypeInternal;
extern C_OFFICE_GET_PERMISSION_ALLDefaultTypeInternal _C_OFFICE_GET_PERMISSION_ALL_default_instance_;
class C_OFFICE_GET_ROOM_INFO;
struct C_OFFICE_GET_ROOM_INFODefaultTypeInternal;
extern C_OFFICE_GET_ROOM_INFODefaultTypeInternal _C_OFFICE_GET_ROOM_INFO_default_instance_;
class C_OFFICE_GET_VIDEO_STREAM;
struct C_OFFICE_GET_VIDEO_STREAMDefaultTypeInternal;
extern C_OFFICE_GET_VIDEO_STREAMDefaultTypeInternal _C_OFFICE_GET_VIDEO_STREAM_default_instance_;
class C_OFFICE_GET_WAITING_LIST;
struct C_OFFICE_GET_WAITING_LISTDefaultTypeInternal;
extern C_OFFICE_GET_WAITING_LISTDefaultTypeInternal _C_OFFICE_GET_WAITING_LIST_default_instance_;
class C_OFFICE_KICK;
struct C_OFFICE_KICKDefaultTypeInternal;
extern C_OFFICE_KICKDefaultTypeInternal _C_OFFICE_KICK_default_instance_;
class C_OFFICE_SET_PERMISSION;
struct C_OFFICE_SET_PERMISSIONDefaultTypeInternal;
extern C_OFFICE_SET_PERMISSIONDefaultTypeInternal _C_OFFICE_SET_PERMISSION_default_instance_;
class C_OFFICE_SET_ROOM_INFO;
struct C_OFFICE_SET_ROOM_INFODefaultTypeInternal;
extern C_OFFICE_SET_ROOM_INFODefaultTypeInternal _C_OFFICE_SET_ROOM_INFO_default_instance_;
class C_OFFICE_SHARE;
struct C_OFFICE_SHAREDefaultTypeInternal;
extern C_OFFICE_SHAREDefaultTypeInternal _C_OFFICE_SHARE_default_instance_;
class C_OFFICE_VIDEO_STREAM;
struct C_OFFICE_VIDEO_STREAMDefaultTypeInternal;
extern C_OFFICE_VIDEO_STREAMDefaultTypeInternal _C_OFFICE_VIDEO_STREAM_default_instance_;
class OfficeUserInfo;
struct OfficeUserInfoDefaultTypeInternal;
extern OfficeUserInfoDefaultTypeInternal _OfficeUserInfo_default_instance_;
class S_OFFICE_ACCEPT_WAIT;
struct S_OFFICE_ACCEPT_WAITDefaultTypeInternal;
extern S_OFFICE_ACCEPT_WAITDefaultTypeInternal _S_OFFICE_ACCEPT_WAIT_default_instance_;
class S_OFFICE_ACCEPT_WAIT_NOTICE;
struct S_OFFICE_ACCEPT_WAIT_NOTICEDefaultTypeInternal;
extern S_OFFICE_ACCEPT_WAIT_NOTICEDefaultTypeInternal _S_OFFICE_ACCEPT_WAIT_NOTICE_default_instance_;
class S_OFFICE_ADD_WAITING_CLIENT;
struct S_OFFICE_ADD_WAITING_CLIENTDefaultTypeInternal;
extern S_OFFICE_ADD_WAITING_CLIENTDefaultTypeInternal _S_OFFICE_ADD_WAITING_CLIENT_default_instance_;
class S_OFFICE_ADD_WAITING_CLIENT_WaitingClient;
struct S_OFFICE_ADD_WAITING_CLIENT_WaitingClientDefaultTypeInternal;
extern S_OFFICE_ADD_WAITING_CLIENT_WaitingClientDefaultTypeInternal _S_OFFICE_ADD_WAITING_CLIENT_WaitingClient_default_instance_;
class S_OFFICE_BREAK;
struct S_OFFICE_BREAKDefaultTypeInternal;
extern S_OFFICE_BREAKDefaultTypeInternal _S_OFFICE_BREAK_default_instance_;
class S_OFFICE_GET_HOST;
struct S_OFFICE_GET_HOSTDefaultTypeInternal;
extern S_OFFICE_GET_HOSTDefaultTypeInternal _S_OFFICE_GET_HOST_default_instance_;
class S_OFFICE_GET_PERMISSION;
struct S_OFFICE_GET_PERMISSIONDefaultTypeInternal;
extern S_OFFICE_GET_PERMISSIONDefaultTypeInternal _S_OFFICE_GET_PERMISSION_default_instance_;
class S_OFFICE_GET_PERMISSION_ALL;
struct S_OFFICE_GET_PERMISSION_ALLDefaultTypeInternal;
extern S_OFFICE_GET_PERMISSION_ALLDefaultTypeInternal _S_OFFICE_GET_PERMISSION_ALL_default_instance_;
class S_OFFICE_GET_ROOM_INFO;
struct S_OFFICE_GET_ROOM_INFODefaultTypeInternal;
extern S_OFFICE_GET_ROOM_INFODefaultTypeInternal _S_OFFICE_GET_ROOM_INFO_default_instance_;
class S_OFFICE_KICK;
struct S_OFFICE_KICKDefaultTypeInternal;
extern S_OFFICE_KICKDefaultTypeInternal _S_OFFICE_KICK_default_instance_;
class S_OFFICE_REMOVE_WAITING_CLIENT;
struct S_OFFICE_REMOVE_WAITING_CLIENTDefaultTypeInternal;
extern S_OFFICE_REMOVE_WAITING_CLIENTDefaultTypeInternal _S_OFFICE_REMOVE_WAITING_CLIENT_default_instance_;
class S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient;
struct S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClientDefaultTypeInternal;
extern S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClientDefaultTypeInternal _S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient_default_instance_;
class S_OFFICE_SET_PERMISSION;
struct S_OFFICE_SET_PERMISSIONDefaultTypeInternal;
extern S_OFFICE_SET_PERMISSIONDefaultTypeInternal _S_OFFICE_SET_PERMISSION_default_instance_;
class S_OFFICE_SET_ROOM_INFO;
struct S_OFFICE_SET_ROOM_INFODefaultTypeInternal;
extern S_OFFICE_SET_ROOM_INFODefaultTypeInternal _S_OFFICE_SET_ROOM_INFO_default_instance_;
class S_OFFICE_SHARE;
struct S_OFFICE_SHAREDefaultTypeInternal;
extern S_OFFICE_SHAREDefaultTypeInternal _S_OFFICE_SHARE_default_instance_;
class S_OFFICE_VIDEO_STREAM;
struct S_OFFICE_VIDEO_STREAMDefaultTypeInternal;
extern S_OFFICE_VIDEO_STREAMDefaultTypeInternal _S_OFFICE_VIDEO_STREAM_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_OFFICE_ACCEPT_WAIT* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_ACCEPT_WAIT>(Arena*);
template<> ::Protocol::C_OFFICE_BREAK* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_BREAK>(Arena*);
template<> ::Protocol::C_OFFICE_GET_HOST* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_HOST>(Arena*);
template<> ::Protocol::C_OFFICE_GET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_PERMISSION>(Arena*);
template<> ::Protocol::C_OFFICE_GET_PERMISSION_ALL* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_PERMISSION_ALL>(Arena*);
template<> ::Protocol::C_OFFICE_GET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_ROOM_INFO>(Arena*);
template<> ::Protocol::C_OFFICE_GET_VIDEO_STREAM* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_VIDEO_STREAM>(Arena*);
template<> ::Protocol::C_OFFICE_GET_WAITING_LIST* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_GET_WAITING_LIST>(Arena*);
template<> ::Protocol::C_OFFICE_KICK* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_KICK>(Arena*);
template<> ::Protocol::C_OFFICE_SET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_SET_PERMISSION>(Arena*);
template<> ::Protocol::C_OFFICE_SET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_SET_ROOM_INFO>(Arena*);
template<> ::Protocol::C_OFFICE_SHARE* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_SHARE>(Arena*);
template<> ::Protocol::C_OFFICE_VIDEO_STREAM* Arena::CreateMaybeMessage<::Protocol::C_OFFICE_VIDEO_STREAM>(Arena*);
template<> ::Protocol::OfficeUserInfo* Arena::CreateMaybeMessage<::Protocol::OfficeUserInfo>(Arena*);
template<> ::Protocol::S_OFFICE_ACCEPT_WAIT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ACCEPT_WAIT>(Arena*);
template<> ::Protocol::S_OFFICE_ACCEPT_WAIT_NOTICE* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ACCEPT_WAIT_NOTICE>(Arena*);
template<> ::Protocol::S_OFFICE_ADD_WAITING_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ADD_WAITING_CLIENT>(Arena*);
template<> ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient>(Arena*);
template<> ::Protocol::S_OFFICE_BREAK* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_BREAK>(Arena*);
template<> ::Protocol::S_OFFICE_GET_HOST* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_HOST>(Arena*);
template<> ::Protocol::S_OFFICE_GET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_PERMISSION>(Arena*);
template<> ::Protocol::S_OFFICE_GET_PERMISSION_ALL* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_PERMISSION_ALL>(Arena*);
template<> ::Protocol::S_OFFICE_GET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_GET_ROOM_INFO>(Arena*);
template<> ::Protocol::S_OFFICE_KICK* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_KICK>(Arena*);
template<> ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT>(Arena*);
template<> ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient>(Arena*);
template<> ::Protocol::S_OFFICE_SET_PERMISSION* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SET_PERMISSION>(Arena*);
template<> ::Protocol::S_OFFICE_SET_ROOM_INFO* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SET_ROOM_INFO>(Arena*);
template<> ::Protocol::S_OFFICE_SHARE* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_SHARE>(Arena*);
template<> ::Protocol::S_OFFICE_VIDEO_STREAM* Arena::CreateMaybeMessage<::Protocol::S_OFFICE_VIDEO_STREAM>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_OFFICE_GET_WAITING_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_WAITING_LIST) */ {
 public:
  inline C_OFFICE_GET_WAITING_LIST() : C_OFFICE_GET_WAITING_LIST(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_WAITING_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_WAITING_LIST(const C_OFFICE_GET_WAITING_LIST& from);
  C_OFFICE_GET_WAITING_LIST(C_OFFICE_GET_WAITING_LIST&& from) noexcept
    : C_OFFICE_GET_WAITING_LIST() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_WAITING_LIST& operator=(const C_OFFICE_GET_WAITING_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_WAITING_LIST& operator=(C_OFFICE_GET_WAITING_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_WAITING_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_WAITING_LIST* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_WAITING_LIST*>(
               &_C_OFFICE_GET_WAITING_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_OFFICE_GET_WAITING_LIST& a, C_OFFICE_GET_WAITING_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_WAITING_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_WAITING_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_WAITING_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_WAITING_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_WAITING_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_WAITING_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_WAITING_LIST";
  }
  protected:
  explicit C_OFFICE_GET_WAITING_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_WAITING_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ADD_WAITING_CLIENT_WaitingClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient) */ {
 public:
  inline S_OFFICE_ADD_WAITING_CLIENT_WaitingClient() : S_OFFICE_ADD_WAITING_CLIENT_WaitingClient(nullptr) {}
  ~S_OFFICE_ADD_WAITING_CLIENT_WaitingClient() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ADD_WAITING_CLIENT_WaitingClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ADD_WAITING_CLIENT_WaitingClient(const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& from);
  S_OFFICE_ADD_WAITING_CLIENT_WaitingClient(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient&& from) noexcept
    : S_OFFICE_ADD_WAITING_CLIENT_WaitingClient() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& operator=(const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& operator=(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient*>(
               &_S_OFFICE_ADD_WAITING_CLIENT_WaitingClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& a, S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ADD_WAITING_CLIENT_WaitingClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& from) {
    S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient";
  }
  protected:
  explicit S_OFFICE_ADD_WAITING_CLIENT_WaitingClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 2,
    kNicknameFieldNumber = 3,
    kIsObserverFieldNumber = 1,
  };
  // string clientId = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string nickname = 3;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // bool isObserver = 1;
  void clear_isobserver();
  bool isobserver() const;
  void set_isobserver(bool value);
  private:
  bool _internal_isobserver() const;
  void _internal_set_isobserver(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    bool isobserver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ADD_WAITING_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ADD_WAITING_CLIENT) */ {
 public:
  inline S_OFFICE_ADD_WAITING_CLIENT() : S_OFFICE_ADD_WAITING_CLIENT(nullptr) {}
  ~S_OFFICE_ADD_WAITING_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ADD_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ADD_WAITING_CLIENT(const S_OFFICE_ADD_WAITING_CLIENT& from);
  S_OFFICE_ADD_WAITING_CLIENT(S_OFFICE_ADD_WAITING_CLIENT&& from) noexcept
    : S_OFFICE_ADD_WAITING_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ADD_WAITING_CLIENT& operator=(const S_OFFICE_ADD_WAITING_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ADD_WAITING_CLIENT& operator=(S_OFFICE_ADD_WAITING_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ADD_WAITING_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ADD_WAITING_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ADD_WAITING_CLIENT*>(
               &_S_OFFICE_ADD_WAITING_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_OFFICE_ADD_WAITING_CLIENT& a, S_OFFICE_ADD_WAITING_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ADD_WAITING_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ADD_WAITING_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ADD_WAITING_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ADD_WAITING_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ADD_WAITING_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ADD_WAITING_CLIENT& from) {
    S_OFFICE_ADD_WAITING_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ADD_WAITING_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ADD_WAITING_CLIENT";
  }
  protected:
  explicit S_OFFICE_ADD_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef S_OFFICE_ADD_WAITING_CLIENT_WaitingClient WaitingClient;

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 1,
  };
  // repeated .Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient clients = 1;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient >*
      mutable_clients();
  private:
  const ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& _internal_clients(int index) const;
  ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* _internal_add_clients();
  public:
  const ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& clients(int index) const;
  ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient >&
      clients() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ADD_WAITING_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient > clients_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient) */ {
 public:
  inline S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient() : S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient(nullptr) {}
  ~S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient(const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& from);
  S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient&& from) noexcept
    : S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& operator=(const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& operator=(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient*>(
               &_S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& a, S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& from) {
    S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient";
  }
  protected:
  explicit S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 2,
    kIsObserverFieldNumber = 1,
  };
  // string clientId = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // bool isObserver = 1;
  void clear_isobserver();
  bool isobserver() const;
  void set_isobserver(bool value);
  private:
  bool _internal_isobserver() const;
  void _internal_set_isobserver(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    bool isobserver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_REMOVE_WAITING_CLIENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT) */ {
 public:
  inline S_OFFICE_REMOVE_WAITING_CLIENT() : S_OFFICE_REMOVE_WAITING_CLIENT(nullptr) {}
  ~S_OFFICE_REMOVE_WAITING_CLIENT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_REMOVE_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_REMOVE_WAITING_CLIENT(const S_OFFICE_REMOVE_WAITING_CLIENT& from);
  S_OFFICE_REMOVE_WAITING_CLIENT(S_OFFICE_REMOVE_WAITING_CLIENT&& from) noexcept
    : S_OFFICE_REMOVE_WAITING_CLIENT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_REMOVE_WAITING_CLIENT& operator=(const S_OFFICE_REMOVE_WAITING_CLIENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_REMOVE_WAITING_CLIENT& operator=(S_OFFICE_REMOVE_WAITING_CLIENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_REMOVE_WAITING_CLIENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_REMOVE_WAITING_CLIENT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_REMOVE_WAITING_CLIENT*>(
               &_S_OFFICE_REMOVE_WAITING_CLIENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(S_OFFICE_REMOVE_WAITING_CLIENT& a, S_OFFICE_REMOVE_WAITING_CLIENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_REMOVE_WAITING_CLIENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_REMOVE_WAITING_CLIENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_REMOVE_WAITING_CLIENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_REMOVE_WAITING_CLIENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_REMOVE_WAITING_CLIENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_REMOVE_WAITING_CLIENT& from) {
    S_OFFICE_REMOVE_WAITING_CLIENT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_REMOVE_WAITING_CLIENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_REMOVE_WAITING_CLIENT";
  }
  protected:
  explicit S_OFFICE_REMOVE_WAITING_CLIENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient WaitingClient;

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 1,
  };
  // repeated .Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient clients = 1;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient >*
      mutable_clients();
  private:
  const ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& _internal_clients(int index) const;
  ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* _internal_add_clients();
  public:
  const ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& clients(int index) const;
  ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient >&
      clients() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient > clients_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_ACCEPT_WAIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_ACCEPT_WAIT) */ {
 public:
  inline C_OFFICE_ACCEPT_WAIT() : C_OFFICE_ACCEPT_WAIT(nullptr) {}
  ~C_OFFICE_ACCEPT_WAIT() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_ACCEPT_WAIT(const C_OFFICE_ACCEPT_WAIT& from);
  C_OFFICE_ACCEPT_WAIT(C_OFFICE_ACCEPT_WAIT&& from) noexcept
    : C_OFFICE_ACCEPT_WAIT() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_ACCEPT_WAIT& operator=(const C_OFFICE_ACCEPT_WAIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_ACCEPT_WAIT& operator=(C_OFFICE_ACCEPT_WAIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_ACCEPT_WAIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_ACCEPT_WAIT* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_ACCEPT_WAIT*>(
               &_C_OFFICE_ACCEPT_WAIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_OFFICE_ACCEPT_WAIT& a, C_OFFICE_ACCEPT_WAIT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_ACCEPT_WAIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_ACCEPT_WAIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_ACCEPT_WAIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_ACCEPT_WAIT& from) {
    C_OFFICE_ACCEPT_WAIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_ACCEPT_WAIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_ACCEPT_WAIT";
  }
  protected:
  explicit C_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kIsAcceptedFieldNumber = 2,
  };
  // repeated string clientId = 1;
  int clientid_size() const;
  private:
  int _internal_clientid_size() const;
  public:
  void clear_clientid();
  const std::string& clientid(int index) const;
  std::string* mutable_clientid(int index);
  void set_clientid(int index, const std::string& value);
  void set_clientid(int index, std::string&& value);
  void set_clientid(int index, const char* value);
  void set_clientid(int index, const char* value, size_t size);
  std::string* add_clientid();
  void add_clientid(const std::string& value);
  void add_clientid(std::string&& value);
  void add_clientid(const char* value);
  void add_clientid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clientid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clientid();
  private:
  const std::string& _internal_clientid(int index) const;
  std::string* _internal_add_clientid();
  public:

  // bool isAccepted = 2;
  void clear_isaccepted();
  bool isaccepted() const;
  void set_isaccepted(bool value);
  private:
  bool _internal_isaccepted() const;
  void _internal_set_isaccepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_ACCEPT_WAIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clientid_;
    bool isaccepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ACCEPT_WAIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ACCEPT_WAIT) */ {
 public:
  inline S_OFFICE_ACCEPT_WAIT() : S_OFFICE_ACCEPT_WAIT(nullptr) {}
  ~S_OFFICE_ACCEPT_WAIT() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ACCEPT_WAIT(const S_OFFICE_ACCEPT_WAIT& from);
  S_OFFICE_ACCEPT_WAIT(S_OFFICE_ACCEPT_WAIT&& from) noexcept
    : S_OFFICE_ACCEPT_WAIT() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ACCEPT_WAIT& operator=(const S_OFFICE_ACCEPT_WAIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ACCEPT_WAIT& operator=(S_OFFICE_ACCEPT_WAIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ACCEPT_WAIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ACCEPT_WAIT* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ACCEPT_WAIT*>(
               &_S_OFFICE_ACCEPT_WAIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_OFFICE_ACCEPT_WAIT& a, S_OFFICE_ACCEPT_WAIT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ACCEPT_WAIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ACCEPT_WAIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ACCEPT_WAIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ACCEPT_WAIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ACCEPT_WAIT& from) {
    S_OFFICE_ACCEPT_WAIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ACCEPT_WAIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ACCEPT_WAIT";
  }
  protected:
  explicit S_OFFICE_ACCEPT_WAIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ACCEPT_WAIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_ACCEPT_WAIT_NOTICE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE) */ {
 public:
  inline S_OFFICE_ACCEPT_WAIT_NOTICE() : S_OFFICE_ACCEPT_WAIT_NOTICE(nullptr) {}
  ~S_OFFICE_ACCEPT_WAIT_NOTICE() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_ACCEPT_WAIT_NOTICE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_ACCEPT_WAIT_NOTICE(const S_OFFICE_ACCEPT_WAIT_NOTICE& from);
  S_OFFICE_ACCEPT_WAIT_NOTICE(S_OFFICE_ACCEPT_WAIT_NOTICE&& from) noexcept
    : S_OFFICE_ACCEPT_WAIT_NOTICE() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_ACCEPT_WAIT_NOTICE& operator=(const S_OFFICE_ACCEPT_WAIT_NOTICE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_ACCEPT_WAIT_NOTICE& operator=(S_OFFICE_ACCEPT_WAIT_NOTICE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_ACCEPT_WAIT_NOTICE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_ACCEPT_WAIT_NOTICE* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_ACCEPT_WAIT_NOTICE*>(
               &_S_OFFICE_ACCEPT_WAIT_NOTICE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_OFFICE_ACCEPT_WAIT_NOTICE& a, S_OFFICE_ACCEPT_WAIT_NOTICE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_ACCEPT_WAIT_NOTICE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_ACCEPT_WAIT_NOTICE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_ACCEPT_WAIT_NOTICE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_ACCEPT_WAIT_NOTICE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_ACCEPT_WAIT_NOTICE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_ACCEPT_WAIT_NOTICE& from) {
    S_OFFICE_ACCEPT_WAIT_NOTICE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_ACCEPT_WAIT_NOTICE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE";
  }
  protected:
  explicit S_OFFICE_ACCEPT_WAIT_NOTICE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAcceptedFieldNumber = 1,
  };
  // bool isAccepted = 1;
  void clear_isaccepted();
  bool isaccepted() const;
  void set_isaccepted(bool value);
  private:
  bool _internal_isaccepted() const;
  void _internal_set_isaccepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isaccepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_HOST final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_HOST) */ {
 public:
  inline C_OFFICE_GET_HOST() : C_OFFICE_GET_HOST(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_HOST(const C_OFFICE_GET_HOST& from);
  C_OFFICE_GET_HOST(C_OFFICE_GET_HOST&& from) noexcept
    : C_OFFICE_GET_HOST() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_HOST& operator=(const C_OFFICE_GET_HOST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_HOST& operator=(C_OFFICE_GET_HOST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_HOST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_HOST* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_HOST*>(
               &_C_OFFICE_GET_HOST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(C_OFFICE_GET_HOST& a, C_OFFICE_GET_HOST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_HOST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_HOST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_HOST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_HOST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_HOST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_HOST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_HOST";
  }
  protected:
  explicit C_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_HOST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_HOST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_HOST) */ {
 public:
  inline S_OFFICE_GET_HOST() : S_OFFICE_GET_HOST(nullptr) {}
  ~S_OFFICE_GET_HOST() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_HOST(const S_OFFICE_GET_HOST& from);
  S_OFFICE_GET_HOST(S_OFFICE_GET_HOST&& from) noexcept
    : S_OFFICE_GET_HOST() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_HOST& operator=(const S_OFFICE_GET_HOST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_HOST& operator=(S_OFFICE_GET_HOST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_HOST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_HOST* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_HOST*>(
               &_S_OFFICE_GET_HOST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_OFFICE_GET_HOST& a, S_OFFICE_GET_HOST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_HOST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_HOST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_HOST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_HOST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_HOST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_HOST& from) {
    S_OFFICE_GET_HOST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_HOST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_HOST";
  }
  protected:
  explicit S_OFFICE_GET_HOST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_HOST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_BREAK final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_BREAK) */ {
 public:
  inline C_OFFICE_BREAK() : C_OFFICE_BREAK(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_BREAK(const C_OFFICE_BREAK& from);
  C_OFFICE_BREAK(C_OFFICE_BREAK&& from) noexcept
    : C_OFFICE_BREAK() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_BREAK& operator=(const C_OFFICE_BREAK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_BREAK& operator=(C_OFFICE_BREAK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_BREAK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_BREAK* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_BREAK*>(
               &_C_OFFICE_BREAK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_OFFICE_BREAK& a, C_OFFICE_BREAK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_BREAK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_BREAK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_BREAK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_BREAK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_BREAK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_BREAK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_BREAK";
  }
  protected:
  explicit C_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_BREAK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_BREAK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_BREAK) */ {
 public:
  inline S_OFFICE_BREAK() : S_OFFICE_BREAK(nullptr) {}
  ~S_OFFICE_BREAK() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_BREAK(const S_OFFICE_BREAK& from);
  S_OFFICE_BREAK(S_OFFICE_BREAK&& from) noexcept
    : S_OFFICE_BREAK() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_BREAK& operator=(const S_OFFICE_BREAK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_BREAK& operator=(S_OFFICE_BREAK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_BREAK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_BREAK* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_BREAK*>(
               &_S_OFFICE_BREAK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_OFFICE_BREAK& a, S_OFFICE_BREAK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_BREAK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_BREAK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_BREAK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_BREAK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_BREAK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_BREAK& from) {
    S_OFFICE_BREAK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_BREAK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_BREAK";
  }
  protected:
  explicit S_OFFICE_BREAK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_BREAK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_KICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_KICK) */ {
 public:
  inline C_OFFICE_KICK() : C_OFFICE_KICK(nullptr) {}
  ~C_OFFICE_KICK() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_KICK(const C_OFFICE_KICK& from);
  C_OFFICE_KICK(C_OFFICE_KICK&& from) noexcept
    : C_OFFICE_KICK() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_KICK& operator=(const C_OFFICE_KICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_KICK& operator=(C_OFFICE_KICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_KICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_KICK* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_KICK*>(
               &_C_OFFICE_KICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_OFFICE_KICK& a, C_OFFICE_KICK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_KICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_KICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_KICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_KICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_KICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_KICK& from) {
    C_OFFICE_KICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_KICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_KICK";
  }
  protected:
  explicit C_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_KICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_KICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_KICK) */ {
 public:
  inline S_OFFICE_KICK() : S_OFFICE_KICK(nullptr) {}
  ~S_OFFICE_KICK() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_KICK(const S_OFFICE_KICK& from);
  S_OFFICE_KICK(S_OFFICE_KICK&& from) noexcept
    : S_OFFICE_KICK() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_KICK& operator=(const S_OFFICE_KICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_KICK& operator=(S_OFFICE_KICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_KICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_KICK* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_KICK*>(
               &_S_OFFICE_KICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_OFFICE_KICK& a, S_OFFICE_KICK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_KICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_KICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_KICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_KICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_KICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_KICK& from) {
    S_OFFICE_KICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_KICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_KICK";
  }
  protected:
  explicit S_OFFICE_KICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_KICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class OfficeUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.OfficeUserInfo) */ {
 public:
  inline OfficeUserInfo() : OfficeUserInfo(nullptr) {}
  ~OfficeUserInfo() override;
  explicit PROTOBUF_CONSTEXPR OfficeUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfficeUserInfo(const OfficeUserInfo& from);
  OfficeUserInfo(OfficeUserInfo&& from) noexcept
    : OfficeUserInfo() {
    *this = ::std::move(from);
  }

  inline OfficeUserInfo& operator=(const OfficeUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfficeUserInfo& operator=(OfficeUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfficeUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfficeUserInfo* internal_default_instance() {
    return reinterpret_cast<const OfficeUserInfo*>(
               &_OfficeUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(OfficeUserInfo& a, OfficeUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OfficeUserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfficeUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfficeUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfficeUserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfficeUserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfficeUserInfo& from) {
    OfficeUserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfficeUserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.OfficeUserInfo";
  }
  protected:
  explicit OfficeUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kScreenPermissionFieldNumber = 2,
    kChatPermissionFieldNumber = 3,
    kVoicePermissionFieldNumber = 4,
    kVideoPermissionFieldNumber = 5,
    kAuthorityFieldNumber = 6,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // bool screenPermission = 2;
  void clear_screenpermission();
  bool screenpermission() const;
  void set_screenpermission(bool value);
  private:
  bool _internal_screenpermission() const;
  void _internal_set_screenpermission(bool value);
  public:

  // bool chatPermission = 3;
  void clear_chatpermission();
  bool chatpermission() const;
  void set_chatpermission(bool value);
  private:
  bool _internal_chatpermission() const;
  void _internal_set_chatpermission(bool value);
  public:

  // bool voicePermission = 4;
  void clear_voicepermission();
  bool voicepermission() const;
  void set_voicepermission(bool value);
  private:
  bool _internal_voicepermission() const;
  void _internal_set_voicepermission(bool value);
  public:

  // bool videoPermission = 5;
  void clear_videopermission();
  bool videopermission() const;
  void set_videopermission(bool value);
  private:
  bool _internal_videopermission() const;
  void _internal_set_videopermission(bool value);
  public:

  // int32 authority = 6;
  void clear_authority();
  int32_t authority() const;
  void set_authority(int32_t value);
  private:
  int32_t _internal_authority() const;
  void _internal_set_authority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.OfficeUserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    bool screenpermission_;
    bool chatpermission_;
    bool voicepermission_;
    bool videopermission_;
    int32_t authority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_PERMISSION) */ {
 public:
  inline C_OFFICE_GET_PERMISSION() : C_OFFICE_GET_PERMISSION(nullptr) {}
  ~C_OFFICE_GET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_PERMISSION(const C_OFFICE_GET_PERMISSION& from);
  C_OFFICE_GET_PERMISSION(C_OFFICE_GET_PERMISSION&& from) noexcept
    : C_OFFICE_GET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_PERMISSION& operator=(const C_OFFICE_GET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_PERMISSION& operator=(C_OFFICE_GET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_PERMISSION*>(
               &_C_OFFICE_GET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_OFFICE_GET_PERMISSION& a, C_OFFICE_GET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_GET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_GET_PERMISSION& from) {
    C_OFFICE_GET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_GET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_PERMISSION";
  }
  protected:
  explicit C_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_PERMISSION) */ {
 public:
  inline S_OFFICE_GET_PERMISSION() : S_OFFICE_GET_PERMISSION(nullptr) {}
  ~S_OFFICE_GET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_PERMISSION(const S_OFFICE_GET_PERMISSION& from);
  S_OFFICE_GET_PERMISSION(S_OFFICE_GET_PERMISSION&& from) noexcept
    : S_OFFICE_GET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_PERMISSION& operator=(const S_OFFICE_GET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_PERMISSION& operator=(S_OFFICE_GET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_PERMISSION*>(
               &_S_OFFICE_GET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_OFFICE_GET_PERMISSION& a, S_OFFICE_GET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_PERMISSION& from) {
    S_OFFICE_GET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_PERMISSION";
  }
  protected:
  explicit S_OFFICE_GET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 1,
  };
  // .Protocol.OfficeUserInfo permission = 1;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Protocol::OfficeUserInfo& permission() const;
  PROTOBUF_NODISCARD ::Protocol::OfficeUserInfo* release_permission();
  ::Protocol::OfficeUserInfo* mutable_permission();
  void set_allocated_permission(::Protocol::OfficeUserInfo* permission);
  private:
  const ::Protocol::OfficeUserInfo& _internal_permission() const;
  ::Protocol::OfficeUserInfo* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::Protocol::OfficeUserInfo* permission);
  ::Protocol::OfficeUserInfo* unsafe_arena_release_permission();

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::OfficeUserInfo* permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_PERMISSION_ALL final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_PERMISSION_ALL) */ {
 public:
  inline C_OFFICE_GET_PERMISSION_ALL() : C_OFFICE_GET_PERMISSION_ALL(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_PERMISSION_ALL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_PERMISSION_ALL(const C_OFFICE_GET_PERMISSION_ALL& from);
  C_OFFICE_GET_PERMISSION_ALL(C_OFFICE_GET_PERMISSION_ALL&& from) noexcept
    : C_OFFICE_GET_PERMISSION_ALL() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_PERMISSION_ALL& operator=(const C_OFFICE_GET_PERMISSION_ALL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_PERMISSION_ALL& operator=(C_OFFICE_GET_PERMISSION_ALL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_PERMISSION_ALL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_PERMISSION_ALL* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_PERMISSION_ALL*>(
               &_C_OFFICE_GET_PERMISSION_ALL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_OFFICE_GET_PERMISSION_ALL& a, C_OFFICE_GET_PERMISSION_ALL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_PERMISSION_ALL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_PERMISSION_ALL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_PERMISSION_ALL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_PERMISSION_ALL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_PERMISSION_ALL& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_PERMISSION_ALL& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_PERMISSION_ALL";
  }
  protected:
  explicit C_OFFICE_GET_PERMISSION_ALL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_PERMISSION_ALL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_PERMISSION_ALL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_PERMISSION_ALL) */ {
 public:
  inline S_OFFICE_GET_PERMISSION_ALL() : S_OFFICE_GET_PERMISSION_ALL(nullptr) {}
  ~S_OFFICE_GET_PERMISSION_ALL() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_PERMISSION_ALL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_PERMISSION_ALL(const S_OFFICE_GET_PERMISSION_ALL& from);
  S_OFFICE_GET_PERMISSION_ALL(S_OFFICE_GET_PERMISSION_ALL&& from) noexcept
    : S_OFFICE_GET_PERMISSION_ALL() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_PERMISSION_ALL& operator=(const S_OFFICE_GET_PERMISSION_ALL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_PERMISSION_ALL& operator=(S_OFFICE_GET_PERMISSION_ALL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_PERMISSION_ALL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_PERMISSION_ALL* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_PERMISSION_ALL*>(
               &_S_OFFICE_GET_PERMISSION_ALL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_OFFICE_GET_PERMISSION_ALL& a, S_OFFICE_GET_PERMISSION_ALL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_PERMISSION_ALL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_PERMISSION_ALL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_PERMISSION_ALL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_PERMISSION_ALL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_PERMISSION_ALL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_PERMISSION_ALL& from) {
    S_OFFICE_GET_PERMISSION_ALL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_PERMISSION_ALL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_PERMISSION_ALL";
  }
  protected:
  explicit S_OFFICE_GET_PERMISSION_ALL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .Protocol.OfficeUserInfo permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::Protocol::OfficeUserInfo* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >*
      mutable_permissions();
  private:
  const ::Protocol::OfficeUserInfo& _internal_permissions(int index) const;
  ::Protocol::OfficeUserInfo* _internal_add_permissions();
  public:
  const ::Protocol::OfficeUserInfo& permissions(int index) const;
  ::Protocol::OfficeUserInfo* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_PERMISSION_ALL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo > permissions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_SET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_SET_PERMISSION) */ {
 public:
  inline C_OFFICE_SET_PERMISSION() : C_OFFICE_SET_PERMISSION(nullptr) {}
  ~C_OFFICE_SET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_SET_PERMISSION(const C_OFFICE_SET_PERMISSION& from);
  C_OFFICE_SET_PERMISSION(C_OFFICE_SET_PERMISSION&& from) noexcept
    : C_OFFICE_SET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_SET_PERMISSION& operator=(const C_OFFICE_SET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_SET_PERMISSION& operator=(C_OFFICE_SET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_SET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_SET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_SET_PERMISSION*>(
               &_C_OFFICE_SET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_OFFICE_SET_PERMISSION& a, C_OFFICE_SET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_SET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_SET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_SET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_SET_PERMISSION& from) {
    C_OFFICE_SET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_SET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_SET_PERMISSION";
  }
  protected:
  explicit C_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .Protocol.OfficeUserInfo permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::Protocol::OfficeUserInfo* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >*
      mutable_permissions();
  private:
  const ::Protocol::OfficeUserInfo& _internal_permissions(int index) const;
  ::Protocol::OfficeUserInfo* _internal_add_permissions();
  public:
  const ::Protocol::OfficeUserInfo& permissions(int index) const;
  ::Protocol::OfficeUserInfo* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_SET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo > permissions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SET_PERMISSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SET_PERMISSION) */ {
 public:
  inline S_OFFICE_SET_PERMISSION() : S_OFFICE_SET_PERMISSION(nullptr) {}
  ~S_OFFICE_SET_PERMISSION() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SET_PERMISSION(const S_OFFICE_SET_PERMISSION& from);
  S_OFFICE_SET_PERMISSION(S_OFFICE_SET_PERMISSION&& from) noexcept
    : S_OFFICE_SET_PERMISSION() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SET_PERMISSION& operator=(const S_OFFICE_SET_PERMISSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SET_PERMISSION& operator=(S_OFFICE_SET_PERMISSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SET_PERMISSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SET_PERMISSION* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SET_PERMISSION*>(
               &_S_OFFICE_SET_PERMISSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_OFFICE_SET_PERMISSION& a, S_OFFICE_SET_PERMISSION& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SET_PERMISSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SET_PERMISSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SET_PERMISSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SET_PERMISSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SET_PERMISSION& from) {
    S_OFFICE_SET_PERMISSION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SET_PERMISSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SET_PERMISSION";
  }
  protected:
  explicit S_OFFICE_SET_PERMISSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SET_PERMISSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_SET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_SET_ROOM_INFO) */ {
 public:
  inline C_OFFICE_SET_ROOM_INFO() : C_OFFICE_SET_ROOM_INFO(nullptr) {}
  ~C_OFFICE_SET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_SET_ROOM_INFO(const C_OFFICE_SET_ROOM_INFO& from);
  C_OFFICE_SET_ROOM_INFO(C_OFFICE_SET_ROOM_INFO&& from) noexcept
    : C_OFFICE_SET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_SET_ROOM_INFO& operator=(const C_OFFICE_SET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_SET_ROOM_INFO& operator=(C_OFFICE_SET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_SET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_SET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_SET_ROOM_INFO*>(
               &_C_OFFICE_SET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_OFFICE_SET_ROOM_INFO& a, C_OFFICE_SET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_SET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_SET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_SET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_SET_ROOM_INFO& from) {
    C_OFFICE_SET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_SET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_SET_ROOM_INFO";
  }
  protected:
  explicit C_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kThumbnailFieldNumber = 7,
    kPersonnelFieldNumber = 1,
    kIsShutdownFieldNumber = 3,
    kIsAdvertisingFieldNumber = 4,
    kIsWaitingRoomFieldNumber = 5,
    kRunningTimeFieldNumber = 6,
    kObserverFieldNumber = 8,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string thumbnail = 7;
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // int32 personnel = 1;
  void clear_personnel();
  int32_t personnel() const;
  void set_personnel(int32_t value);
  private:
  int32_t _internal_personnel() const;
  void _internal_set_personnel(int32_t value);
  public:

  // bool isShutdown = 3;
  void clear_isshutdown();
  bool isshutdown() const;
  void set_isshutdown(bool value);
  private:
  bool _internal_isshutdown() const;
  void _internal_set_isshutdown(bool value);
  public:

  // bool isAdvertising = 4;
  void clear_isadvertising();
  bool isadvertising() const;
  void set_isadvertising(bool value);
  private:
  bool _internal_isadvertising() const;
  void _internal_set_isadvertising(bool value);
  public:

  // bool isWaitingRoom = 5;
  void clear_iswaitingroom();
  bool iswaitingroom() const;
  void set_iswaitingroom(bool value);
  private:
  bool _internal_iswaitingroom() const;
  void _internal_set_iswaitingroom(bool value);
  public:

  // int32 runningTime = 6;
  void clear_runningtime();
  int32_t runningtime() const;
  void set_runningtime(int32_t value);
  private:
  int32_t _internal_runningtime() const;
  void _internal_set_runningtime(int32_t value);
  public:

  // int32 observer = 8;
  void clear_observer();
  int32_t observer() const;
  void set_observer(int32_t value);
  private:
  int32_t _internal_observer() const;
  void _internal_set_observer(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_SET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    int32_t personnel_;
    bool isshutdown_;
    bool isadvertising_;
    bool iswaitingroom_;
    int32_t runningtime_;
    int32_t observer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SET_ROOM_INFO) */ {
 public:
  inline S_OFFICE_SET_ROOM_INFO() : S_OFFICE_SET_ROOM_INFO(nullptr) {}
  ~S_OFFICE_SET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SET_ROOM_INFO(const S_OFFICE_SET_ROOM_INFO& from);
  S_OFFICE_SET_ROOM_INFO(S_OFFICE_SET_ROOM_INFO&& from) noexcept
    : S_OFFICE_SET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SET_ROOM_INFO& operator=(const S_OFFICE_SET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SET_ROOM_INFO& operator=(S_OFFICE_SET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SET_ROOM_INFO*>(
               &_S_OFFICE_SET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_OFFICE_SET_ROOM_INFO& a, S_OFFICE_SET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SET_ROOM_INFO& from) {
    S_OFFICE_SET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SET_ROOM_INFO";
  }
  protected:
  explicit S_OFFICE_SET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_ROOM_INFO) */ {
 public:
  inline C_OFFICE_GET_ROOM_INFO() : C_OFFICE_GET_ROOM_INFO(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_ROOM_INFO(const C_OFFICE_GET_ROOM_INFO& from);
  C_OFFICE_GET_ROOM_INFO(C_OFFICE_GET_ROOM_INFO&& from) noexcept
    : C_OFFICE_GET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_ROOM_INFO& operator=(const C_OFFICE_GET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_ROOM_INFO& operator=(C_OFFICE_GET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_ROOM_INFO*>(
               &_C_OFFICE_GET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_OFFICE_GET_ROOM_INFO& a, C_OFFICE_GET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_ROOM_INFO& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_ROOM_INFO& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_ROOM_INFO";
  }
  protected:
  explicit C_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_GET_ROOM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_GET_ROOM_INFO) */ {
 public:
  inline S_OFFICE_GET_ROOM_INFO() : S_OFFICE_GET_ROOM_INFO(nullptr) {}
  ~S_OFFICE_GET_ROOM_INFO() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_GET_ROOM_INFO(const S_OFFICE_GET_ROOM_INFO& from);
  S_OFFICE_GET_ROOM_INFO(S_OFFICE_GET_ROOM_INFO&& from) noexcept
    : S_OFFICE_GET_ROOM_INFO() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_GET_ROOM_INFO& operator=(const S_OFFICE_GET_ROOM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_GET_ROOM_INFO& operator=(S_OFFICE_GET_ROOM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_GET_ROOM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_GET_ROOM_INFO* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_GET_ROOM_INFO*>(
               &_S_OFFICE_GET_ROOM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_OFFICE_GET_ROOM_INFO& a, S_OFFICE_GET_ROOM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_GET_ROOM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_GET_ROOM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_GET_ROOM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_GET_ROOM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_GET_ROOM_INFO& from) {
    S_OFFICE_GET_ROOM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_GET_ROOM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_GET_ROOM_INFO";
  }
  protected:
  explicit S_OFFICE_GET_ROOM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kPasswordFieldNumber = 4,
    kSpaceInfoIdFieldNumber = 5,
    kThumbnailFieldNumber = 12,
    kStartTimeFieldNumber = 17,
    kRoomcodeFieldNumber = 18,
    kHostNicknameFieldNumber = 19,
    kTopicTypeFieldNumber = 3,
    kPersonnelFieldNumber = 6,
    kCurrentPersonnelFieldNumber = 7,
    kObserverFieldNumber = 8,
    kCurrentObserverFieldNumber = 9,
    kCurrentWaitingFieldNumber = 10,
    kIsAdvertisingFieldNumber = 11,
    kIsWaitingRoomFieldNumber = 13,
    kIsShutdownFieldNumber = 14,
    kRunningTimeFieldNumber = 15,
    kPassedTimeFieldNumber = 16,
  };
  // string roomName = 1;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string spaceInfoId = 5;
  void clear_spaceinfoid();
  const std::string& spaceinfoid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceinfoid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceinfoid();
  PROTOBUF_NODISCARD std::string* release_spaceinfoid();
  void set_allocated_spaceinfoid(std::string* spaceinfoid);
  private:
  const std::string& _internal_spaceinfoid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceinfoid(const std::string& value);
  std::string* _internal_mutable_spaceinfoid();
  public:

  // string thumbnail = 12;
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // string startTime = 17;
  void clear_starttime();
  const std::string& starttime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_starttime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_starttime();
  PROTOBUF_NODISCARD std::string* release_starttime();
  void set_allocated_starttime(std::string* starttime);
  private:
  const std::string& _internal_starttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_starttime(const std::string& value);
  std::string* _internal_mutable_starttime();
  public:

  // string roomcode = 18;
  void clear_roomcode();
  const std::string& roomcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomcode();
  PROTOBUF_NODISCARD std::string* release_roomcode();
  void set_allocated_roomcode(std::string* roomcode);
  private:
  const std::string& _internal_roomcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomcode(const std::string& value);
  std::string* _internal_mutable_roomcode();
  public:

  // string hostNickname = 19;
  void clear_hostnickname();
  const std::string& hostnickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostnickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostnickname();
  PROTOBUF_NODISCARD std::string* release_hostnickname();
  void set_allocated_hostnickname(std::string* hostnickname);
  private:
  const std::string& _internal_hostnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostnickname(const std::string& value);
  std::string* _internal_mutable_hostnickname();
  public:

  // int32 topicType = 3;
  void clear_topictype();
  int32_t topictype() const;
  void set_topictype(int32_t value);
  private:
  int32_t _internal_topictype() const;
  void _internal_set_topictype(int32_t value);
  public:

  // int32 personnel = 6;
  void clear_personnel();
  int32_t personnel() const;
  void set_personnel(int32_t value);
  private:
  int32_t _internal_personnel() const;
  void _internal_set_personnel(int32_t value);
  public:

  // int32 currentPersonnel = 7;
  void clear_currentpersonnel();
  int32_t currentpersonnel() const;
  void set_currentpersonnel(int32_t value);
  private:
  int32_t _internal_currentpersonnel() const;
  void _internal_set_currentpersonnel(int32_t value);
  public:

  // int32 observer = 8;
  void clear_observer();
  int32_t observer() const;
  void set_observer(int32_t value);
  private:
  int32_t _internal_observer() const;
  void _internal_set_observer(int32_t value);
  public:

  // int32 currentObserver = 9;
  void clear_currentobserver();
  int32_t currentobserver() const;
  void set_currentobserver(int32_t value);
  private:
  int32_t _internal_currentobserver() const;
  void _internal_set_currentobserver(int32_t value);
  public:

  // int32 currentWaiting = 10;
  void clear_currentwaiting();
  int32_t currentwaiting() const;
  void set_currentwaiting(int32_t value);
  private:
  int32_t _internal_currentwaiting() const;
  void _internal_set_currentwaiting(int32_t value);
  public:

  // bool isAdvertising = 11;
  void clear_isadvertising();
  bool isadvertising() const;
  void set_isadvertising(bool value);
  private:
  bool _internal_isadvertising() const;
  void _internal_set_isadvertising(bool value);
  public:

  // bool isWaitingRoom = 13;
  void clear_iswaitingroom();
  bool iswaitingroom() const;
  void set_iswaitingroom(bool value);
  private:
  bool _internal_iswaitingroom() const;
  void _internal_set_iswaitingroom(bool value);
  public:

  // bool isShutdown = 14;
  void clear_isshutdown();
  bool isshutdown() const;
  void set_isshutdown(bool value);
  private:
  bool _internal_isshutdown() const;
  void _internal_set_isshutdown(bool value);
  public:

  // int32 runningTime = 15;
  void clear_runningtime();
  int32_t runningtime() const;
  void set_runningtime(int32_t value);
  private:
  int32_t _internal_runningtime() const;
  void _internal_set_runningtime(int32_t value);
  public:

  // int32 passedTime = 16;
  void clear_passedtime();
  int32_t passedtime() const;
  void set_passedtime(int32_t value);
  private:
  int32_t _internal_passedtime() const;
  void _internal_set_passedtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_GET_ROOM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceinfoid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr starttime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostnickname_;
    int32_t topictype_;
    int32_t personnel_;
    int32_t currentpersonnel_;
    int32_t observer_;
    int32_t currentobserver_;
    int32_t currentwaiting_;
    bool isadvertising_;
    bool iswaitingroom_;
    bool isshutdown_;
    int32_t runningtime_;
    int32_t passedtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_VIDEO_STREAM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_VIDEO_STREAM) */ {
 public:
  inline C_OFFICE_VIDEO_STREAM() : C_OFFICE_VIDEO_STREAM(nullptr) {}
  ~C_OFFICE_VIDEO_STREAM() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_VIDEO_STREAM(const C_OFFICE_VIDEO_STREAM& from);
  C_OFFICE_VIDEO_STREAM(C_OFFICE_VIDEO_STREAM&& from) noexcept
    : C_OFFICE_VIDEO_STREAM() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_VIDEO_STREAM& operator=(const C_OFFICE_VIDEO_STREAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_VIDEO_STREAM& operator=(C_OFFICE_VIDEO_STREAM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_VIDEO_STREAM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_VIDEO_STREAM* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_VIDEO_STREAM*>(
               &_C_OFFICE_VIDEO_STREAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_OFFICE_VIDEO_STREAM& a, C_OFFICE_VIDEO_STREAM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_VIDEO_STREAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_VIDEO_STREAM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_VIDEO_STREAM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_VIDEO_STREAM& from) {
    C_OFFICE_VIDEO_STREAM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_VIDEO_STREAM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_VIDEO_STREAM";
  }
  protected:
  explicit C_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientidFieldNumber = 1,
    kUrlFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kPlayFieldNumber = 5,
    kSeekFieldNumber = 6,
    kMediaPlayerStateFieldNumber = 7,
  };
  // string clientid = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // float volume = 3;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float time = 4;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // bool play = 5;
  void clear_play();
  bool play() const;
  void set_play(bool value);
  private:
  bool _internal_play() const;
  void _internal_set_play(bool value);
  public:

  // bool seek = 6;
  void clear_seek();
  bool seek() const;
  void set_seek(bool value);
  private:
  bool _internal_seek() const;
  void _internal_set_seek(bool value);
  public:

  // int32 mediaPlayerState = 7;
  void clear_mediaplayerstate();
  int32_t mediaplayerstate() const;
  void set_mediaplayerstate(int32_t value);
  private:
  int32_t _internal_mediaplayerstate() const;
  void _internal_set_mediaplayerstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_VIDEO_STREAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    float volume_;
    float time_;
    bool play_;
    bool seek_;
    int32_t mediaplayerstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_GET_VIDEO_STREAM final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_GET_VIDEO_STREAM) */ {
 public:
  inline C_OFFICE_GET_VIDEO_STREAM() : C_OFFICE_GET_VIDEO_STREAM(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_OFFICE_GET_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_GET_VIDEO_STREAM(const C_OFFICE_GET_VIDEO_STREAM& from);
  C_OFFICE_GET_VIDEO_STREAM(C_OFFICE_GET_VIDEO_STREAM&& from) noexcept
    : C_OFFICE_GET_VIDEO_STREAM() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_GET_VIDEO_STREAM& operator=(const C_OFFICE_GET_VIDEO_STREAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_GET_VIDEO_STREAM& operator=(C_OFFICE_GET_VIDEO_STREAM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_GET_VIDEO_STREAM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_GET_VIDEO_STREAM* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_GET_VIDEO_STREAM*>(
               &_C_OFFICE_GET_VIDEO_STREAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_OFFICE_GET_VIDEO_STREAM& a, C_OFFICE_GET_VIDEO_STREAM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_GET_VIDEO_STREAM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_GET_VIDEO_STREAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_GET_VIDEO_STREAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_GET_VIDEO_STREAM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_OFFICE_GET_VIDEO_STREAM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_OFFICE_GET_VIDEO_STREAM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_GET_VIDEO_STREAM";
  }
  protected:
  explicit C_OFFICE_GET_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_GET_VIDEO_STREAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_VIDEO_STREAM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_VIDEO_STREAM) */ {
 public:
  inline S_OFFICE_VIDEO_STREAM() : S_OFFICE_VIDEO_STREAM(nullptr) {}
  ~S_OFFICE_VIDEO_STREAM() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_VIDEO_STREAM(const S_OFFICE_VIDEO_STREAM& from);
  S_OFFICE_VIDEO_STREAM(S_OFFICE_VIDEO_STREAM&& from) noexcept
    : S_OFFICE_VIDEO_STREAM() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_VIDEO_STREAM& operator=(const S_OFFICE_VIDEO_STREAM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_VIDEO_STREAM& operator=(S_OFFICE_VIDEO_STREAM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_VIDEO_STREAM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_VIDEO_STREAM* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_VIDEO_STREAM*>(
               &_S_OFFICE_VIDEO_STREAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_OFFICE_VIDEO_STREAM& a, S_OFFICE_VIDEO_STREAM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_VIDEO_STREAM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_VIDEO_STREAM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_VIDEO_STREAM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_VIDEO_STREAM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_VIDEO_STREAM& from) {
    S_OFFICE_VIDEO_STREAM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_VIDEO_STREAM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_VIDEO_STREAM";
  }
  protected:
  explicit S_OFFICE_VIDEO_STREAM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientidFieldNumber = 1,
    kUrlFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kPlayFieldNumber = 5,
    kSeekFieldNumber = 6,
    kMediaPlayerStateFieldNumber = 7,
  };
  // string clientid = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // float volume = 3;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float time = 4;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // bool play = 5;
  void clear_play();
  bool play() const;
  void set_play(bool value);
  private:
  bool _internal_play() const;
  void _internal_set_play(bool value);
  public:

  // bool seek = 6;
  void clear_seek();
  bool seek() const;
  void set_seek(bool value);
  private:
  bool _internal_seek() const;
  void _internal_set_seek(bool value);
  public:

  // int32 mediaPlayerState = 7;
  void clear_mediaplayerstate();
  int32_t mediaplayerstate() const;
  void set_mediaplayerstate(int32_t value);
  private:
  int32_t _internal_mediaplayerstate() const;
  void _internal_set_mediaplayerstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_VIDEO_STREAM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    float volume_;
    float time_;
    bool play_;
    bool seek_;
    int32_t mediaplayerstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class C_OFFICE_SHARE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_OFFICE_SHARE) */ {
 public:
  inline C_OFFICE_SHARE() : C_OFFICE_SHARE(nullptr) {}
  ~C_OFFICE_SHARE() override;
  explicit PROTOBUF_CONSTEXPR C_OFFICE_SHARE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_OFFICE_SHARE(const C_OFFICE_SHARE& from);
  C_OFFICE_SHARE(C_OFFICE_SHARE&& from) noexcept
    : C_OFFICE_SHARE() {
    *this = ::std::move(from);
  }

  inline C_OFFICE_SHARE& operator=(const C_OFFICE_SHARE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_OFFICE_SHARE& operator=(C_OFFICE_SHARE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_OFFICE_SHARE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_OFFICE_SHARE* internal_default_instance() {
    return reinterpret_cast<const C_OFFICE_SHARE*>(
               &_C_OFFICE_SHARE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(C_OFFICE_SHARE& a, C_OFFICE_SHARE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_OFFICE_SHARE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_OFFICE_SHARE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_OFFICE_SHARE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_OFFICE_SHARE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_OFFICE_SHARE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_OFFICE_SHARE& from) {
    C_OFFICE_SHARE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_OFFICE_SHARE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_OFFICE_SHARE";
  }
  protected:
  explicit C_OFFICE_SHARE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSharedFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // bool isShared = 1;
  void clear_isshared();
  bool isshared() const;
  void set_isshared(bool value);
  private:
  bool _internal_isshared() const;
  void _internal_set_isshared(bool value);
  public:

  // int32 userId = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_OFFICE_SHARE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isshared_;
    int32_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// -------------------------------------------------------------------

class S_OFFICE_SHARE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_OFFICE_SHARE) */ {
 public:
  inline S_OFFICE_SHARE() : S_OFFICE_SHARE(nullptr) {}
  ~S_OFFICE_SHARE() override;
  explicit PROTOBUF_CONSTEXPR S_OFFICE_SHARE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OFFICE_SHARE(const S_OFFICE_SHARE& from);
  S_OFFICE_SHARE(S_OFFICE_SHARE&& from) noexcept
    : S_OFFICE_SHARE() {
    *this = ::std::move(from);
  }

  inline S_OFFICE_SHARE& operator=(const S_OFFICE_SHARE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OFFICE_SHARE& operator=(S_OFFICE_SHARE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OFFICE_SHARE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OFFICE_SHARE* internal_default_instance() {
    return reinterpret_cast<const S_OFFICE_SHARE*>(
               &_S_OFFICE_SHARE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_OFFICE_SHARE& a, S_OFFICE_SHARE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OFFICE_SHARE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OFFICE_SHARE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OFFICE_SHARE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OFFICE_SHARE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OFFICE_SHARE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_OFFICE_SHARE& from) {
    S_OFFICE_SHARE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OFFICE_SHARE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_OFFICE_SHARE";
  }
  protected:
  explicit S_OFFICE_SHARE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSharedFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // bool isShared = 1;
  void clear_isshared();
  bool isshared() const;
  void set_isshared(bool value);
  private:
  bool _internal_isshared() const;
  void _internal_set_isshared(bool value);
  public:

  // int32 userId = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_OFFICE_SHARE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isshared_;
    int32_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Packet_5f004_5fOffice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_OFFICE_GET_WAITING_LIST

// -------------------------------------------------------------------

// S_OFFICE_ADD_WAITING_CLIENT_WaitingClient

// bool isObserver = 1;
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::clear_isobserver() {
  _impl_.isobserver_ = false;
}
inline bool S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_isobserver() const {
  return _impl_.isobserver_;
}
inline bool S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::isobserver() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.isObserver)
  return _internal_isobserver();
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_set_isobserver(bool value) {
  
  _impl_.isobserver_ = value;
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::set_isobserver(bool value) {
  _internal_set_isobserver(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.isObserver)
}

// string clientId = 2;
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.clientId)
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.clientId)
  return _s;
}
inline const std::string& S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.clientId)
  return _impl_.clientid_.Release();
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.clientId)
}

// string nickname = 3;
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.nickname)
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.nickname)
  return _s;
}
inline const std::string& S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.nickname)
  return _impl_.nickname_.Release();
}
inline void S_OFFICE_ADD_WAITING_CLIENT_WaitingClient::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient.nickname)
}

// -------------------------------------------------------------------

// S_OFFICE_ADD_WAITING_CLIENT

// repeated .Protocol.S_OFFICE_ADD_WAITING_CLIENT.WaitingClient clients = 1;
inline int S_OFFICE_ADD_WAITING_CLIENT::_internal_clients_size() const {
  return _impl_.clients_.size();
}
inline int S_OFFICE_ADD_WAITING_CLIENT::clients_size() const {
  return _internal_clients_size();
}
inline void S_OFFICE_ADD_WAITING_CLIENT::clear_clients() {
  _impl_.clients_.Clear();
}
inline ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* S_OFFICE_ADD_WAITING_CLIENT::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _impl_.clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient >*
S_OFFICE_ADD_WAITING_CLIENT::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return &_impl_.clients_;
}
inline const ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& S_OFFICE_ADD_WAITING_CLIENT::_internal_clients(int index) const {
  return _impl_.clients_.Get(index);
}
inline const ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient& S_OFFICE_ADD_WAITING_CLIENT::clients(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _internal_clients(index);
}
inline ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* S_OFFICE_ADD_WAITING_CLIENT::_internal_add_clients() {
  return _impl_.clients_.Add();
}
inline ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* S_OFFICE_ADD_WAITING_CLIENT::add_clients() {
  ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient* _add = _internal_add_clients();
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_ADD_WAITING_CLIENT_WaitingClient >&
S_OFFICE_ADD_WAITING_CLIENT::clients() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_ADD_WAITING_CLIENT.clients)
  return _impl_.clients_;
}

// -------------------------------------------------------------------

// S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient

// bool isObserver = 1;
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::clear_isobserver() {
  _impl_.isobserver_ = false;
}
inline bool S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::_internal_isobserver() const {
  return _impl_.isobserver_;
}
inline bool S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::isobserver() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.isObserver)
  return _internal_isobserver();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::_internal_set_isobserver(bool value) {
  
  _impl_.isobserver_ = value;
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::set_isobserver(bool value) {
  _internal_set_isobserver(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.isObserver)
}

// string clientId = 2;
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.clientId)
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.clientId)
  return _s;
}
inline const std::string& S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.clientId)
  return _impl_.clientid_.Release();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient.clientId)
}

// -------------------------------------------------------------------

// S_OFFICE_REMOVE_WAITING_CLIENT

// repeated .Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.WaitingClient clients = 1;
inline int S_OFFICE_REMOVE_WAITING_CLIENT::_internal_clients_size() const {
  return _impl_.clients_.size();
}
inline int S_OFFICE_REMOVE_WAITING_CLIENT::clients_size() const {
  return _internal_clients_size();
}
inline void S_OFFICE_REMOVE_WAITING_CLIENT::clear_clients() {
  _impl_.clients_.Clear();
}
inline ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* S_OFFICE_REMOVE_WAITING_CLIENT::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _impl_.clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient >*
S_OFFICE_REMOVE_WAITING_CLIENT::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return &_impl_.clients_;
}
inline const ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& S_OFFICE_REMOVE_WAITING_CLIENT::_internal_clients(int index) const {
  return _impl_.clients_.Get(index);
}
inline const ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient& S_OFFICE_REMOVE_WAITING_CLIENT::clients(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _internal_clients(index);
}
inline ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* S_OFFICE_REMOVE_WAITING_CLIENT::_internal_add_clients() {
  return _impl_.clients_.Add();
}
inline ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* S_OFFICE_REMOVE_WAITING_CLIENT::add_clients() {
  ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient* _add = _internal_add_clients();
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::S_OFFICE_REMOVE_WAITING_CLIENT_WaitingClient >&
S_OFFICE_REMOVE_WAITING_CLIENT::clients() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_REMOVE_WAITING_CLIENT.clients)
  return _impl_.clients_;
}

// -------------------------------------------------------------------

// C_OFFICE_ACCEPT_WAIT

// repeated string clientId = 1;
inline int C_OFFICE_ACCEPT_WAIT::_internal_clientid_size() const {
  return _impl_.clientid_.size();
}
inline int C_OFFICE_ACCEPT_WAIT::clientid_size() const {
  return _internal_clientid_size();
}
inline void C_OFFICE_ACCEPT_WAIT::clear_clientid() {
  _impl_.clientid_.Clear();
}
inline std::string* C_OFFICE_ACCEPT_WAIT::add_clientid() {
  std::string* _s = _internal_add_clientid();
  // @@protoc_insertion_point(field_add_mutable:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _s;
}
inline const std::string& C_OFFICE_ACCEPT_WAIT::_internal_clientid(int index) const {
  return _impl_.clientid_.Get(index);
}
inline const std::string& C_OFFICE_ACCEPT_WAIT::clientid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _internal_clientid(index);
}
inline std::string* C_OFFICE_ACCEPT_WAIT::mutable_clientid(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _impl_.clientid_.Mutable(index);
}
inline void C_OFFICE_ACCEPT_WAIT::set_clientid(int index, const std::string& value) {
  _impl_.clientid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::set_clientid(int index, std::string&& value) {
  _impl_.clientid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::set_clientid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clientid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::set_clientid(int index, const char* value, size_t size) {
  _impl_.clientid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline std::string* C_OFFICE_ACCEPT_WAIT::_internal_add_clientid() {
  return _impl_.clientid_.Add();
}
inline void C_OFFICE_ACCEPT_WAIT::add_clientid(const std::string& value) {
  _impl_.clientid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::add_clientid(std::string&& value) {
  _impl_.clientid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::add_clientid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.clientid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline void C_OFFICE_ACCEPT_WAIT::add_clientid(const char* value, size_t size) {
  _impl_.clientid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
C_OFFICE_ACCEPT_WAIT::clientid() const {
  // @@protoc_insertion_point(field_list:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return _impl_.clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
C_OFFICE_ACCEPT_WAIT::mutable_clientid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_OFFICE_ACCEPT_WAIT.clientId)
  return &_impl_.clientid_;
}

// bool isAccepted = 2;
inline void C_OFFICE_ACCEPT_WAIT::clear_isaccepted() {
  _impl_.isaccepted_ = false;
}
inline bool C_OFFICE_ACCEPT_WAIT::_internal_isaccepted() const {
  return _impl_.isaccepted_;
}
inline bool C_OFFICE_ACCEPT_WAIT::isaccepted() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_ACCEPT_WAIT.isAccepted)
  return _internal_isaccepted();
}
inline void C_OFFICE_ACCEPT_WAIT::_internal_set_isaccepted(bool value) {
  
  _impl_.isaccepted_ = value;
}
inline void C_OFFICE_ACCEPT_WAIT::set_isaccepted(bool value) {
  _internal_set_isaccepted(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_ACCEPT_WAIT.isAccepted)
}

// -------------------------------------------------------------------

// S_OFFICE_ACCEPT_WAIT

// bool success = 1;
inline void S_OFFICE_ACCEPT_WAIT::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_ACCEPT_WAIT::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_ACCEPT_WAIT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ACCEPT_WAIT.success)
  return _internal_success();
}
inline void S_OFFICE_ACCEPT_WAIT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_ACCEPT_WAIT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ACCEPT_WAIT.success)
}

// -------------------------------------------------------------------

// S_OFFICE_ACCEPT_WAIT_NOTICE

// bool isAccepted = 1;
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::clear_isaccepted() {
  _impl_.isaccepted_ = false;
}
inline bool S_OFFICE_ACCEPT_WAIT_NOTICE::_internal_isaccepted() const {
  return _impl_.isaccepted_;
}
inline bool S_OFFICE_ACCEPT_WAIT_NOTICE::isaccepted() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE.isAccepted)
  return _internal_isaccepted();
}
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::_internal_set_isaccepted(bool value) {
  
  _impl_.isaccepted_ = value;
}
inline void S_OFFICE_ACCEPT_WAIT_NOTICE::set_isaccepted(bool value) {
  _internal_set_isaccepted(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_ACCEPT_WAIT_NOTICE.isAccepted)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_HOST

// -------------------------------------------------------------------

// S_OFFICE_GET_HOST

// string clientId = 1;
inline void S_OFFICE_GET_HOST::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_HOST::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_HOST.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_HOST::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_HOST.clientId)
}
inline std::string* S_OFFICE_GET_HOST::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_HOST.clientId)
  return _s;
}
inline const std::string& S_OFFICE_GET_HOST::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_OFFICE_GET_HOST::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_HOST::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_HOST::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_HOST.clientId)
  return _impl_.clientid_.Release();
}
inline void S_OFFICE_GET_HOST::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_HOST.clientId)
}

// -------------------------------------------------------------------

// C_OFFICE_BREAK

// -------------------------------------------------------------------

// S_OFFICE_BREAK

// bool success = 1;
inline void S_OFFICE_BREAK::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_BREAK::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_BREAK::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_BREAK.success)
  return _internal_success();
}
inline void S_OFFICE_BREAK::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_BREAK::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_BREAK.success)
}

// -------------------------------------------------------------------

// C_OFFICE_KICK

// string clientId = 1;
inline void C_OFFICE_KICK::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_KICK::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_KICK.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_KICK::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_KICK.clientId)
}
inline std::string* C_OFFICE_KICK::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_KICK.clientId)
  return _s;
}
inline const std::string& C_OFFICE_KICK::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_KICK::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_KICK::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_KICK::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_KICK.clientId)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_KICK::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_KICK.clientId)
}

// -------------------------------------------------------------------

// S_OFFICE_KICK

// bool success = 1;
inline void S_OFFICE_KICK::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_KICK::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_KICK::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_KICK.success)
  return _internal_success();
}
inline void S_OFFICE_KICK::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_KICK::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_KICK.success)
}

// -------------------------------------------------------------------

// OfficeUserInfo

// string clientId = 1;
inline void OfficeUserInfo::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& OfficeUserInfo::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfficeUserInfo::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.clientId)
}
inline std::string* OfficeUserInfo::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.OfficeUserInfo.clientId)
  return _s;
}
inline const std::string& OfficeUserInfo::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void OfficeUserInfo::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* OfficeUserInfo::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* OfficeUserInfo::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.OfficeUserInfo.clientId)
  return _impl_.clientid_.Release();
}
inline void OfficeUserInfo::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.OfficeUserInfo.clientId)
}

// bool screenPermission = 2;
inline void OfficeUserInfo::clear_screenpermission() {
  _impl_.screenpermission_ = false;
}
inline bool OfficeUserInfo::_internal_screenpermission() const {
  return _impl_.screenpermission_;
}
inline bool OfficeUserInfo::screenpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.screenPermission)
  return _internal_screenpermission();
}
inline void OfficeUserInfo::_internal_set_screenpermission(bool value) {
  
  _impl_.screenpermission_ = value;
}
inline void OfficeUserInfo::set_screenpermission(bool value) {
  _internal_set_screenpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.screenPermission)
}

// bool chatPermission = 3;
inline void OfficeUserInfo::clear_chatpermission() {
  _impl_.chatpermission_ = false;
}
inline bool OfficeUserInfo::_internal_chatpermission() const {
  return _impl_.chatpermission_;
}
inline bool OfficeUserInfo::chatpermission() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.chatPermission)
  return _internal_chatpermission();
}
inline void OfficeUserInfo::_internal_set_chatpermission(bool value) {
  
  _impl_.chatpermission_ = value;
}
inline void OfficeUserInfo::set_chatpermission(bool value) {
  _internal_set_chatpermission(value);
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.chatPermission)
}

// bool voicePermission = 4;
inline void OfficeUserInfo::clear_voicepermission() {
  _impl_.voicepermission_ = false;
}
inline bool OfficeUserInfo::_internal_voicepermission() const {
  return _impl_.voicepermission_;
}
inline bool OfficeUserInfo::voicepermission() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.voicePermission)
  return _internal_voicepermission();
}
inline void OfficeUserInfo::_internal_set_voicepermission(bool value) {
  
  _impl_.voicepermission_ = value;
}
inline void OfficeUserInfo::set_voicepermission(bool value) {
  _internal_set_voicepermission(value);
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.voicePermission)
}

// bool videoPermission = 5;
inline void OfficeUserInfo::clear_videopermission() {
  _impl_.videopermission_ = false;
}
inline bool OfficeUserInfo::_internal_videopermission() const {
  return _impl_.videopermission_;
}
inline bool OfficeUserInfo::videopermission() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.videoPermission)
  return _internal_videopermission();
}
inline void OfficeUserInfo::_internal_set_videopermission(bool value) {
  
  _impl_.videopermission_ = value;
}
inline void OfficeUserInfo::set_videopermission(bool value) {
  _internal_set_videopermission(value);
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.videoPermission)
}

// int32 authority = 6;
inline void OfficeUserInfo::clear_authority() {
  _impl_.authority_ = 0;
}
inline int32_t OfficeUserInfo::_internal_authority() const {
  return _impl_.authority_;
}
inline int32_t OfficeUserInfo::authority() const {
  // @@protoc_insertion_point(field_get:Protocol.OfficeUserInfo.authority)
  return _internal_authority();
}
inline void OfficeUserInfo::_internal_set_authority(int32_t value) {
  
  _impl_.authority_ = value;
}
inline void OfficeUserInfo::set_authority(int32_t value) {
  _internal_set_authority(value);
  // @@protoc_insertion_point(field_set:Protocol.OfficeUserInfo.authority)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_PERMISSION

// string clientId = 1;
inline void C_OFFICE_GET_PERMISSION::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_GET_PERMISSION::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_GET_PERMISSION::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_GET_PERMISSION.clientId)
}
inline std::string* C_OFFICE_GET_PERMISSION::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _s;
}
inline const std::string& C_OFFICE_GET_PERMISSION::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_GET_PERMISSION::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_GET_PERMISSION::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_GET_PERMISSION::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_GET_PERMISSION.clientId)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_GET_PERMISSION::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_GET_PERMISSION.clientId)
}

// -------------------------------------------------------------------

// S_OFFICE_GET_PERMISSION

// .Protocol.OfficeUserInfo permission = 1;
inline bool S_OFFICE_GET_PERMISSION::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool S_OFFICE_GET_PERMISSION::has_permission() const {
  return _internal_has_permission();
}
inline void S_OFFICE_GET_PERMISSION::clear_permission() {
  if (GetArenaForAllocation() == nullptr && _impl_.permission_ != nullptr) {
    delete _impl_.permission_;
  }
  _impl_.permission_ = nullptr;
}
inline const ::Protocol::OfficeUserInfo& S_OFFICE_GET_PERMISSION::_internal_permission() const {
  const ::Protocol::OfficeUserInfo* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::OfficeUserInfo&>(
      ::Protocol::_OfficeUserInfo_default_instance_);
}
inline const ::Protocol::OfficeUserInfo& S_OFFICE_GET_PERMISSION::permission() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_PERMISSION.permission)
  return _internal_permission();
}
inline void S_OFFICE_GET_PERMISSION::unsafe_arena_set_allocated_permission(
    ::Protocol::OfficeUserInfo* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_OFFICE_GET_PERMISSION.permission)
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION::release_permission() {
  
  ::Protocol::OfficeUserInfo* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_PERMISSION.permission)
  
  ::Protocol::OfficeUserInfo* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::OfficeUserInfo>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION::mutable_permission() {
  ::Protocol::OfficeUserInfo* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_PERMISSION.permission)
  return _msg;
}
inline void S_OFFICE_GET_PERMISSION::set_allocated_permission(::Protocol::OfficeUserInfo* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_PERMISSION.permission)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_PERMISSION_ALL

// -------------------------------------------------------------------

// S_OFFICE_GET_PERMISSION_ALL

// repeated .Protocol.OfficeUserInfo permissions = 1;
inline int S_OFFICE_GET_PERMISSION_ALL::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int S_OFFICE_GET_PERMISSION_ALL::permissions_size() const {
  return _internal_permissions_size();
}
inline void S_OFFICE_GET_PERMISSION_ALL::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION_ALL::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_PERMISSION_ALL.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >*
S_OFFICE_GET_PERMISSION_ALL::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_OFFICE_GET_PERMISSION_ALL.permissions)
  return &_impl_.permissions_;
}
inline const ::Protocol::OfficeUserInfo& S_OFFICE_GET_PERMISSION_ALL::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::Protocol::OfficeUserInfo& S_OFFICE_GET_PERMISSION_ALL::permissions(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_PERMISSION_ALL.permissions)
  return _internal_permissions(index);
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION_ALL::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::Protocol::OfficeUserInfo* S_OFFICE_GET_PERMISSION_ALL::add_permissions() {
  ::Protocol::OfficeUserInfo* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:Protocol.S_OFFICE_GET_PERMISSION_ALL.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >&
S_OFFICE_GET_PERMISSION_ALL::permissions() const {
  // @@protoc_insertion_point(field_list:Protocol.S_OFFICE_GET_PERMISSION_ALL.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// C_OFFICE_SET_PERMISSION

// repeated .Protocol.OfficeUserInfo permissions = 1;
inline int C_OFFICE_SET_PERMISSION::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int C_OFFICE_SET_PERMISSION::permissions_size() const {
  return _internal_permissions_size();
}
inline void C_OFFICE_SET_PERMISSION::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::Protocol::OfficeUserInfo* C_OFFICE_SET_PERMISSION::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >*
C_OFFICE_SET_PERMISSION::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return &_impl_.permissions_;
}
inline const ::Protocol::OfficeUserInfo& C_OFFICE_SET_PERMISSION::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::Protocol::OfficeUserInfo& C_OFFICE_SET_PERMISSION::permissions(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _internal_permissions(index);
}
inline ::Protocol::OfficeUserInfo* C_OFFICE_SET_PERMISSION::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::Protocol::OfficeUserInfo* C_OFFICE_SET_PERMISSION::add_permissions() {
  ::Protocol::OfficeUserInfo* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::OfficeUserInfo >&
C_OFFICE_SET_PERMISSION::permissions() const {
  // @@protoc_insertion_point(field_list:Protocol.C_OFFICE_SET_PERMISSION.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// S_OFFICE_SET_PERMISSION

// string code = 1;
inline void S_OFFICE_SET_PERMISSION::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& S_OFFICE_SET_PERMISSION::code() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_PERMISSION.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_SET_PERMISSION::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_PERMISSION.code)
}
inline std::string* S_OFFICE_SET_PERMISSION::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_SET_PERMISSION.code)
  return _s;
}
inline const std::string& S_OFFICE_SET_PERMISSION::_internal_code() const {
  return _impl_.code_.Get();
}
inline void S_OFFICE_SET_PERMISSION::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_SET_PERMISSION::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_SET_PERMISSION::release_code() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_SET_PERMISSION.code)
  return _impl_.code_.Release();
}
inline void S_OFFICE_SET_PERMISSION::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_SET_PERMISSION.code)
}

// -------------------------------------------------------------------

// C_OFFICE_SET_ROOM_INFO

// int32 personnel = 1;
inline void C_OFFICE_SET_ROOM_INFO::clear_personnel() {
  _impl_.personnel_ = 0;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::_internal_personnel() const {
  return _impl_.personnel_;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::personnel() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.personnel)
  return _internal_personnel();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_personnel(int32_t value) {
  
  _impl_.personnel_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_personnel(int32_t value) {
  _internal_set_personnel(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.personnel)
}

// string password = 2;
inline void C_OFFICE_SET_ROOM_INFO::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_SET_ROOM_INFO::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.password)
}
inline std::string* C_OFFICE_SET_ROOM_INFO::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _s;
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::_internal_password() const {
  return _impl_.password_.Get();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_SET_ROOM_INFO.password)
  return _impl_.password_.Release();
}
inline void C_OFFICE_SET_ROOM_INFO::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_SET_ROOM_INFO.password)
}

// bool isShutdown = 3;
inline void C_OFFICE_SET_ROOM_INFO::clear_isshutdown() {
  _impl_.isshutdown_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_isshutdown() const {
  return _impl_.isshutdown_;
}
inline bool C_OFFICE_SET_ROOM_INFO::isshutdown() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isShutdown)
  return _internal_isshutdown();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_isshutdown(bool value) {
  
  _impl_.isshutdown_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_isshutdown(bool value) {
  _internal_set_isshutdown(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isShutdown)
}

// bool isAdvertising = 4;
inline void C_OFFICE_SET_ROOM_INFO::clear_isadvertising() {
  _impl_.isadvertising_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_isadvertising() const {
  return _impl_.isadvertising_;
}
inline bool C_OFFICE_SET_ROOM_INFO::isadvertising() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isAdvertising)
  return _internal_isadvertising();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_isadvertising(bool value) {
  
  _impl_.isadvertising_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_isadvertising(bool value) {
  _internal_set_isadvertising(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isAdvertising)
}

// bool isWaitingRoom = 5;
inline void C_OFFICE_SET_ROOM_INFO::clear_iswaitingroom() {
  _impl_.iswaitingroom_ = false;
}
inline bool C_OFFICE_SET_ROOM_INFO::_internal_iswaitingroom() const {
  return _impl_.iswaitingroom_;
}
inline bool C_OFFICE_SET_ROOM_INFO::iswaitingroom() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.isWaitingRoom)
  return _internal_iswaitingroom();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_iswaitingroom(bool value) {
  
  _impl_.iswaitingroom_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_iswaitingroom(bool value) {
  _internal_set_iswaitingroom(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.isWaitingRoom)
}

// int32 runningTime = 6;
inline void C_OFFICE_SET_ROOM_INFO::clear_runningtime() {
  _impl_.runningtime_ = 0;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::_internal_runningtime() const {
  return _impl_.runningtime_;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::runningtime() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.runningTime)
  return _internal_runningtime();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_runningtime(int32_t value) {
  
  _impl_.runningtime_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_runningtime(int32_t value) {
  _internal_set_runningtime(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.runningTime)
}

// string thumbnail = 7;
inline void C_OFFICE_SET_ROOM_INFO::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::thumbnail() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_SET_ROOM_INFO::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.thumbnail)
}
inline std::string* C_OFFICE_SET_ROOM_INFO::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_SET_ROOM_INFO.thumbnail)
  return _s;
}
inline const std::string& C_OFFICE_SET_ROOM_INFO::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_thumbnail(const std::string& value) {
  
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::_internal_mutable_thumbnail() {
  
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_SET_ROOM_INFO::release_thumbnail() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_SET_ROOM_INFO.thumbnail)
  return _impl_.thumbnail_.Release();
}
inline void C_OFFICE_SET_ROOM_INFO::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_SET_ROOM_INFO.thumbnail)
}

// int32 observer = 8;
inline void C_OFFICE_SET_ROOM_INFO::clear_observer() {
  _impl_.observer_ = 0;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::_internal_observer() const {
  return _impl_.observer_;
}
inline int32_t C_OFFICE_SET_ROOM_INFO::observer() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SET_ROOM_INFO.observer)
  return _internal_observer();
}
inline void C_OFFICE_SET_ROOM_INFO::_internal_set_observer(int32_t value) {
  
  _impl_.observer_ = value;
}
inline void C_OFFICE_SET_ROOM_INFO::set_observer(int32_t value) {
  _internal_set_observer(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SET_ROOM_INFO.observer)
}

// -------------------------------------------------------------------

// S_OFFICE_SET_ROOM_INFO

// bool success = 1;
inline void S_OFFICE_SET_ROOM_INFO::clear_success() {
  _impl_.success_ = false;
}
inline bool S_OFFICE_SET_ROOM_INFO::_internal_success() const {
  return _impl_.success_;
}
inline bool S_OFFICE_SET_ROOM_INFO::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SET_ROOM_INFO.success)
  return _internal_success();
}
inline void S_OFFICE_SET_ROOM_INFO::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_OFFICE_SET_ROOM_INFO::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SET_ROOM_INFO.success)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_ROOM_INFO

// -------------------------------------------------------------------

// S_OFFICE_GET_ROOM_INFO

// string roomName = 1;
inline void S_OFFICE_GET_ROOM_INFO::clear_roomname() {
  _impl_.roomname_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::roomname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_roomname() const {
  return _impl_.roomname_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_roomname(const std::string& value) {
  
  _impl_.roomname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_roomname() {
  
  return _impl_.roomname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_roomname() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
  return _impl_.roomname_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  _impl_.roomname_.SetAllocated(roomname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomname_.IsDefault()) {
    _impl_.roomname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.roomName)
}

// string description = 2;
inline void S_OFFICE_GET_ROOM_INFO::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::description() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.description)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_description() const {
  return _impl_.description_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_description() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.description)
  return _impl_.description_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.description)
}

// int32 topicType = 3;
inline void S_OFFICE_GET_ROOM_INFO::clear_topictype() {
  _impl_.topictype_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_topictype() const {
  return _impl_.topictype_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::topictype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.topicType)
  return _internal_topictype();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_topictype(int32_t value) {
  
  _impl_.topictype_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_topictype(int32_t value) {
  _internal_set_topictype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.topicType)
}

// string password = 4;
inline void S_OFFICE_GET_ROOM_INFO::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::password() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.password)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_password() const {
  return _impl_.password_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.password)
  return _impl_.password_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.password)
}

// string spaceInfoId = 5;
inline void S_OFFICE_GET_ROOM_INFO::clear_spaceinfoid() {
  _impl_.spaceinfoid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::spaceinfoid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _internal_spaceinfoid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_spaceinfoid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceinfoid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_spaceinfoid() {
  std::string* _s = _internal_mutable_spaceinfoid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_spaceinfoid() const {
  return _impl_.spaceinfoid_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_spaceinfoid(const std::string& value) {
  
  _impl_.spaceinfoid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_spaceinfoid() {
  
  return _impl_.spaceinfoid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_spaceinfoid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
  return _impl_.spaceinfoid_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_spaceinfoid(std::string* spaceinfoid) {
  if (spaceinfoid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceinfoid_.SetAllocated(spaceinfoid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceinfoid_.IsDefault()) {
    _impl_.spaceinfoid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.spaceInfoId)
}

// int32 personnel = 6;
inline void S_OFFICE_GET_ROOM_INFO::clear_personnel() {
  _impl_.personnel_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_personnel() const {
  return _impl_.personnel_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::personnel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.personnel)
  return _internal_personnel();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_personnel(int32_t value) {
  
  _impl_.personnel_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_personnel(int32_t value) {
  _internal_set_personnel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.personnel)
}

// int32 currentPersonnel = 7;
inline void S_OFFICE_GET_ROOM_INFO::clear_currentpersonnel() {
  _impl_.currentpersonnel_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_currentpersonnel() const {
  return _impl_.currentpersonnel_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::currentpersonnel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.currentPersonnel)
  return _internal_currentpersonnel();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_currentpersonnel(int32_t value) {
  
  _impl_.currentpersonnel_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_currentpersonnel(int32_t value) {
  _internal_set_currentpersonnel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.currentPersonnel)
}

// int32 observer = 8;
inline void S_OFFICE_GET_ROOM_INFO::clear_observer() {
  _impl_.observer_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_observer() const {
  return _impl_.observer_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::observer() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.observer)
  return _internal_observer();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_observer(int32_t value) {
  
  _impl_.observer_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_observer(int32_t value) {
  _internal_set_observer(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.observer)
}

// int32 currentObserver = 9;
inline void S_OFFICE_GET_ROOM_INFO::clear_currentobserver() {
  _impl_.currentobserver_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_currentobserver() const {
  return _impl_.currentobserver_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::currentobserver() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.currentObserver)
  return _internal_currentobserver();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_currentobserver(int32_t value) {
  
  _impl_.currentobserver_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_currentobserver(int32_t value) {
  _internal_set_currentobserver(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.currentObserver)
}

// int32 currentWaiting = 10;
inline void S_OFFICE_GET_ROOM_INFO::clear_currentwaiting() {
  _impl_.currentwaiting_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_currentwaiting() const {
  return _impl_.currentwaiting_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::currentwaiting() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.currentWaiting)
  return _internal_currentwaiting();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_currentwaiting(int32_t value) {
  
  _impl_.currentwaiting_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_currentwaiting(int32_t value) {
  _internal_set_currentwaiting(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.currentWaiting)
}

// bool isAdvertising = 11;
inline void S_OFFICE_GET_ROOM_INFO::clear_isadvertising() {
  _impl_.isadvertising_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_isadvertising() const {
  return _impl_.isadvertising_;
}
inline bool S_OFFICE_GET_ROOM_INFO::isadvertising() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isAdvertising)
  return _internal_isadvertising();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_isadvertising(bool value) {
  
  _impl_.isadvertising_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_isadvertising(bool value) {
  _internal_set_isadvertising(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isAdvertising)
}

// string thumbnail = 12;
inline void S_OFFICE_GET_ROOM_INFO::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::thumbnail() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_thumbnail(const std::string& value) {
  
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_thumbnail() {
  
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_thumbnail() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
  return _impl_.thumbnail_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.thumbnail)
}

// bool isWaitingRoom = 13;
inline void S_OFFICE_GET_ROOM_INFO::clear_iswaitingroom() {
  _impl_.iswaitingroom_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_iswaitingroom() const {
  return _impl_.iswaitingroom_;
}
inline bool S_OFFICE_GET_ROOM_INFO::iswaitingroom() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isWaitingRoom)
  return _internal_iswaitingroom();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_iswaitingroom(bool value) {
  
  _impl_.iswaitingroom_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_iswaitingroom(bool value) {
  _internal_set_iswaitingroom(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isWaitingRoom)
}

// bool isShutdown = 14;
inline void S_OFFICE_GET_ROOM_INFO::clear_isshutdown() {
  _impl_.isshutdown_ = false;
}
inline bool S_OFFICE_GET_ROOM_INFO::_internal_isshutdown() const {
  return _impl_.isshutdown_;
}
inline bool S_OFFICE_GET_ROOM_INFO::isshutdown() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.isShutdown)
  return _internal_isshutdown();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_isshutdown(bool value) {
  
  _impl_.isshutdown_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_isshutdown(bool value) {
  _internal_set_isshutdown(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.isShutdown)
}

// int32 runningTime = 15;
inline void S_OFFICE_GET_ROOM_INFO::clear_runningtime() {
  _impl_.runningtime_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_runningtime() const {
  return _impl_.runningtime_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::runningtime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.runningTime)
  return _internal_runningtime();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_runningtime(int32_t value) {
  
  _impl_.runningtime_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_runningtime(int32_t value) {
  _internal_set_runningtime(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.runningTime)
}

// int32 passedTime = 16;
inline void S_OFFICE_GET_ROOM_INFO::clear_passedtime() {
  _impl_.passedtime_ = 0;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::_internal_passedtime() const {
  return _impl_.passedtime_;
}
inline int32_t S_OFFICE_GET_ROOM_INFO::passedtime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.passedTime)
  return _internal_passedtime();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_passedtime(int32_t value) {
  
  _impl_.passedtime_ = value;
}
inline void S_OFFICE_GET_ROOM_INFO::set_passedtime(int32_t value) {
  _internal_set_passedtime(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.passedTime)
}

// string startTime = 17;
inline void S_OFFICE_GET_ROOM_INFO::clear_starttime() {
  _impl_.starttime_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::starttime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.startTime)
  return _internal_starttime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_starttime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.starttime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.startTime)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_starttime() {
  std::string* _s = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.startTime)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_starttime() const {
  return _impl_.starttime_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_starttime(const std::string& value) {
  
  _impl_.starttime_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_starttime() {
  
  return _impl_.starttime_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_starttime() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.startTime)
  return _impl_.starttime_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_starttime(std::string* starttime) {
  if (starttime != nullptr) {
    
  } else {
    
  }
  _impl_.starttime_.SetAllocated(starttime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.starttime_.IsDefault()) {
    _impl_.starttime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.startTime)
}

// string roomcode = 18;
inline void S_OFFICE_GET_ROOM_INFO::clear_roomcode() {
  _impl_.roomcode_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::roomcode() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _internal_roomcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_roomcode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_roomcode() {
  std::string* _s = _internal_mutable_roomcode();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_roomcode() const {
  return _impl_.roomcode_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_roomcode(const std::string& value) {
  
  _impl_.roomcode_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_roomcode() {
  
  return _impl_.roomcode_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_roomcode() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
  return _impl_.roomcode_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_roomcode(std::string* roomcode) {
  if (roomcode != nullptr) {
    
  } else {
    
  }
  _impl_.roomcode_.SetAllocated(roomcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomcode_.IsDefault()) {
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.roomcode)
}

// string hostNickname = 19;
inline void S_OFFICE_GET_ROOM_INFO::clear_hostnickname() {
  _impl_.hostnickname_.ClearToEmpty();
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::hostnickname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _internal_hostnickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_GET_ROOM_INFO::set_hostnickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostnickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
}
inline std::string* S_OFFICE_GET_ROOM_INFO::mutable_hostnickname() {
  std::string* _s = _internal_mutable_hostnickname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _s;
}
inline const std::string& S_OFFICE_GET_ROOM_INFO::_internal_hostnickname() const {
  return _impl_.hostnickname_.Get();
}
inline void S_OFFICE_GET_ROOM_INFO::_internal_set_hostnickname(const std::string& value) {
  
  _impl_.hostnickname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::_internal_mutable_hostnickname() {
  
  return _impl_.hostnickname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_GET_ROOM_INFO::release_hostnickname() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
  return _impl_.hostnickname_.Release();
}
inline void S_OFFICE_GET_ROOM_INFO::set_allocated_hostnickname(std::string* hostnickname) {
  if (hostnickname != nullptr) {
    
  } else {
    
  }
  _impl_.hostnickname_.SetAllocated(hostnickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostnickname_.IsDefault()) {
    _impl_.hostnickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_GET_ROOM_INFO.hostNickname)
}

// -------------------------------------------------------------------

// C_OFFICE_VIDEO_STREAM

// string clientid = 1;
inline void C_OFFICE_VIDEO_STREAM::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& C_OFFICE_VIDEO_STREAM::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_VIDEO_STREAM::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
}
inline std::string* C_OFFICE_VIDEO_STREAM::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _s;
}
inline const std::string& C_OFFICE_VIDEO_STREAM::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
  return _impl_.clientid_.Release();
}
inline void C_OFFICE_VIDEO_STREAM::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_VIDEO_STREAM.clientid)
}

// string url = 2;
inline void C_OFFICE_VIDEO_STREAM::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& C_OFFICE_VIDEO_STREAM::url() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_OFFICE_VIDEO_STREAM::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.url)
}
inline std::string* C_OFFICE_VIDEO_STREAM::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _s;
}
inline const std::string& C_OFFICE_VIDEO_STREAM::_internal_url() const {
  return _impl_.url_.Get();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* C_OFFICE_VIDEO_STREAM::release_url() {
  // @@protoc_insertion_point(field_release:Protocol.C_OFFICE_VIDEO_STREAM.url)
  return _impl_.url_.Release();
}
inline void C_OFFICE_VIDEO_STREAM::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_OFFICE_VIDEO_STREAM.url)
}

// float volume = 3;
inline void C_OFFICE_VIDEO_STREAM::clear_volume() {
  _impl_.volume_ = 0;
}
inline float C_OFFICE_VIDEO_STREAM::_internal_volume() const {
  return _impl_.volume_;
}
inline float C_OFFICE_VIDEO_STREAM::volume() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.volume)
  return _internal_volume();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_volume(float value) {
  
  _impl_.volume_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.volume)
}

// float time = 4;
inline void C_OFFICE_VIDEO_STREAM::clear_time() {
  _impl_.time_ = 0;
}
inline float C_OFFICE_VIDEO_STREAM::_internal_time() const {
  return _impl_.time_;
}
inline float C_OFFICE_VIDEO_STREAM::time() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.time)
  return _internal_time();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.time)
}

// bool play = 5;
inline void C_OFFICE_VIDEO_STREAM::clear_play() {
  _impl_.play_ = false;
}
inline bool C_OFFICE_VIDEO_STREAM::_internal_play() const {
  return _impl_.play_;
}
inline bool C_OFFICE_VIDEO_STREAM::play() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.play)
  return _internal_play();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_play(bool value) {
  
  _impl_.play_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_play(bool value) {
  _internal_set_play(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.play)
}

// bool seek = 6;
inline void C_OFFICE_VIDEO_STREAM::clear_seek() {
  _impl_.seek_ = false;
}
inline bool C_OFFICE_VIDEO_STREAM::_internal_seek() const {
  return _impl_.seek_;
}
inline bool C_OFFICE_VIDEO_STREAM::seek() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.seek)
  return _internal_seek();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_seek(bool value) {
  
  _impl_.seek_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_seek(bool value) {
  _internal_set_seek(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.seek)
}

// int32 mediaPlayerState = 7;
inline void C_OFFICE_VIDEO_STREAM::clear_mediaplayerstate() {
  _impl_.mediaplayerstate_ = 0;
}
inline int32_t C_OFFICE_VIDEO_STREAM::_internal_mediaplayerstate() const {
  return _impl_.mediaplayerstate_;
}
inline int32_t C_OFFICE_VIDEO_STREAM::mediaplayerstate() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_VIDEO_STREAM.mediaPlayerState)
  return _internal_mediaplayerstate();
}
inline void C_OFFICE_VIDEO_STREAM::_internal_set_mediaplayerstate(int32_t value) {
  
  _impl_.mediaplayerstate_ = value;
}
inline void C_OFFICE_VIDEO_STREAM::set_mediaplayerstate(int32_t value) {
  _internal_set_mediaplayerstate(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_VIDEO_STREAM.mediaPlayerState)
}

// -------------------------------------------------------------------

// C_OFFICE_GET_VIDEO_STREAM

// -------------------------------------------------------------------

// S_OFFICE_VIDEO_STREAM

// string clientid = 1;
inline void S_OFFICE_VIDEO_STREAM::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& S_OFFICE_VIDEO_STREAM::clientid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.clientid)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_VIDEO_STREAM::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.clientid)
}
inline std::string* S_OFFICE_VIDEO_STREAM::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_VIDEO_STREAM.clientid)
  return _s;
}
inline const std::string& S_OFFICE_VIDEO_STREAM::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_clientid(const std::string& value) {
  
  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::_internal_mutable_clientid() {
  
  return _impl_.clientid_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::release_clientid() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_VIDEO_STREAM.clientid)
  return _impl_.clientid_.Release();
}
inline void S_OFFICE_VIDEO_STREAM::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  _impl_.clientid_.SetAllocated(clientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientid_.IsDefault()) {
    _impl_.clientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_VIDEO_STREAM.clientid)
}

// string url = 2;
inline void S_OFFICE_VIDEO_STREAM::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& S_OFFICE_VIDEO_STREAM::url() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_OFFICE_VIDEO_STREAM::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.url)
}
inline std::string* S_OFFICE_VIDEO_STREAM::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _s;
}
inline const std::string& S_OFFICE_VIDEO_STREAM::_internal_url() const {
  return _impl_.url_.Get();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* S_OFFICE_VIDEO_STREAM::release_url() {
  // @@protoc_insertion_point(field_release:Protocol.S_OFFICE_VIDEO_STREAM.url)
  return _impl_.url_.Release();
}
inline void S_OFFICE_VIDEO_STREAM::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_OFFICE_VIDEO_STREAM.url)
}

// float volume = 3;
inline void S_OFFICE_VIDEO_STREAM::clear_volume() {
  _impl_.volume_ = 0;
}
inline float S_OFFICE_VIDEO_STREAM::_internal_volume() const {
  return _impl_.volume_;
}
inline float S_OFFICE_VIDEO_STREAM::volume() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.volume)
  return _internal_volume();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_volume(float value) {
  
  _impl_.volume_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.volume)
}

// float time = 4;
inline void S_OFFICE_VIDEO_STREAM::clear_time() {
  _impl_.time_ = 0;
}
inline float S_OFFICE_VIDEO_STREAM::_internal_time() const {
  return _impl_.time_;
}
inline float S_OFFICE_VIDEO_STREAM::time() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.time)
  return _internal_time();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.time)
}

// bool play = 5;
inline void S_OFFICE_VIDEO_STREAM::clear_play() {
  _impl_.play_ = false;
}
inline bool S_OFFICE_VIDEO_STREAM::_internal_play() const {
  return _impl_.play_;
}
inline bool S_OFFICE_VIDEO_STREAM::play() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.play)
  return _internal_play();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_play(bool value) {
  
  _impl_.play_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_play(bool value) {
  _internal_set_play(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.play)
}

// bool seek = 6;
inline void S_OFFICE_VIDEO_STREAM::clear_seek() {
  _impl_.seek_ = false;
}
inline bool S_OFFICE_VIDEO_STREAM::_internal_seek() const {
  return _impl_.seek_;
}
inline bool S_OFFICE_VIDEO_STREAM::seek() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.seek)
  return _internal_seek();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_seek(bool value) {
  
  _impl_.seek_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_seek(bool value) {
  _internal_set_seek(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.seek)
}

// int32 mediaPlayerState = 7;
inline void S_OFFICE_VIDEO_STREAM::clear_mediaplayerstate() {
  _impl_.mediaplayerstate_ = 0;
}
inline int32_t S_OFFICE_VIDEO_STREAM::_internal_mediaplayerstate() const {
  return _impl_.mediaplayerstate_;
}
inline int32_t S_OFFICE_VIDEO_STREAM::mediaplayerstate() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_VIDEO_STREAM.mediaPlayerState)
  return _internal_mediaplayerstate();
}
inline void S_OFFICE_VIDEO_STREAM::_internal_set_mediaplayerstate(int32_t value) {
  
  _impl_.mediaplayerstate_ = value;
}
inline void S_OFFICE_VIDEO_STREAM::set_mediaplayerstate(int32_t value) {
  _internal_set_mediaplayerstate(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_VIDEO_STREAM.mediaPlayerState)
}

// -------------------------------------------------------------------

// C_OFFICE_SHARE

// bool isShared = 1;
inline void C_OFFICE_SHARE::clear_isshared() {
  _impl_.isshared_ = false;
}
inline bool C_OFFICE_SHARE::_internal_isshared() const {
  return _impl_.isshared_;
}
inline bool C_OFFICE_SHARE::isshared() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SHARE.isShared)
  return _internal_isshared();
}
inline void C_OFFICE_SHARE::_internal_set_isshared(bool value) {
  
  _impl_.isshared_ = value;
}
inline void C_OFFICE_SHARE::set_isshared(bool value) {
  _internal_set_isshared(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SHARE.isShared)
}

// int32 userId = 2;
inline void C_OFFICE_SHARE::clear_userid() {
  _impl_.userid_ = 0;
}
inline int32_t C_OFFICE_SHARE::_internal_userid() const {
  return _impl_.userid_;
}
inline int32_t C_OFFICE_SHARE::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_OFFICE_SHARE.userId)
  return _internal_userid();
}
inline void C_OFFICE_SHARE::_internal_set_userid(int32_t value) {
  
  _impl_.userid_ = value;
}
inline void C_OFFICE_SHARE::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_OFFICE_SHARE.userId)
}

// -------------------------------------------------------------------

// S_OFFICE_SHARE

// bool isShared = 1;
inline void S_OFFICE_SHARE::clear_isshared() {
  _impl_.isshared_ = false;
}
inline bool S_OFFICE_SHARE::_internal_isshared() const {
  return _impl_.isshared_;
}
inline bool S_OFFICE_SHARE::isshared() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SHARE.isShared)
  return _internal_isshared();
}
inline void S_OFFICE_SHARE::_internal_set_isshared(bool value) {
  
  _impl_.isshared_ = value;
}
inline void S_OFFICE_SHARE::set_isshared(bool value) {
  _internal_set_isshared(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SHARE.isShared)
}

// int32 userId = 2;
inline void S_OFFICE_SHARE::clear_userid() {
  _impl_.userid_ = 0;
}
inline int32_t S_OFFICE_SHARE::_internal_userid() const {
  return _impl_.userid_;
}
inline int32_t S_OFFICE_SHARE::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_OFFICE_SHARE.userId)
  return _internal_userid();
}
inline void S_OFFICE_SHARE::_internal_set_userid(int32_t value) {
  
  _impl_.userid_ = value;
}
inline void S_OFFICE_SHARE::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_OFFICE_SHARE.userId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Packet_5f004_5fOffice_2eproto
